<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Mesh Loader - Specification</title>

    <link rel="stylesheet" href="style/spec.css">
    <link href='https://fonts.googleapis.com/css?family=JetBrains Mono' rel='stylesheet'>
</head>
<body>

<div id="wrapper">

    <aside>
        <h3>Table of Contents</h3>

        <a href="meshLoaderSpecification.html"> Home Page </a>
        <ul id="navigationTree" class="nav-list">
        </ul>
    </aside>

    <main id="specificationBody">

        <div>

            <h1 id="introduction"> 1. Introduction </h1>

        </div>

        <div>

            <h1 id="fundamentals"> 2. Fundamentals </h1>

            <div>

                <h2 id="fundamentals-environment"> 2.1. Environment </h2>

                <p> The Mesh Loader library and the Mesh Loader library specification requires and assumes the following properties of the build and runtime environment: </p>

                <ul>
                    <li>
                        The environment <strong> must </strong> have runtime support for 8, 16, 32 and 64-bit signed and unsigned twos-complement integers
                        <ul>
                            <li> When building from source, most c11 implementations cover this requirement. </li>
                            <li> When building from source, all c2x implementations cover this requirement. </li>
                        </ul>
                    </li>

                    <li>
                        The environment <strong> must </strong> have runtime support for 32 and 64-bit float point types.
                        <ul>
                            <li> When building from source, all c11 implementations cover this requirement. </li>
                            <li> These are used in the implementation using their standard types. </li>
                        </ul>
                    </li>
                    <li>
                        The environment <strong> must </strong> have runtime support for the std-atomic library.
                        <ul>
                            <li> When building from source, all c11 implementations cover this requirement. </li>
                        </ul>
                    </li>
                </ul>

                <p> Headers provided by the API:
                    <a id="fundamentals-headers"></a> </p>

                <ul>
                    <li> For standard API calls, use <code>include/meshLoader/meshLoader</code>. </li>
                    <li> For only standard API types, use <code>include/meshLoader/publicTypes</code>. These are included in <code>include/meshLoader</code> </li>
                    <li> For custom job interfaces, use <code>include/meshLoader/customJob</code>. </li>
                    <li> For utility functions, use <code>include/meshLoader/utility</code>. </li>
                </ul>

                <p> Header usage example: </p>
<pre lang="c">
#include &lt;meshLoader/meshLoader&gt;
</pre>

            </div>

            <div>
                <h2 id="fundamentals-executionModel"> 2.2. Execution Model </h2>

                <p> This section outlines the execution model of the Mesh Loader library. </p>

                <p> The library uses a number of threads to load a number of mesh objects or other data in the background of the running application.
                    The data loaded is ordered, processed and stored in Job objects. These jobs are processed by Worker objects, each worker running on
                    an individual processor execution thread. </p>

                <p> Jobs are processed in a piece-meal manner, each Worker acquiring a Job from a library Instance and processing a part of the
                    loading, releasing it afterwards back to the instance. This ensures resource-safe, efficient start, pause, resume and stop capabilities. </p>

                <p> Jobs are also processed via priority, and by type. Furthermore, the API can be expanded with user-defined Custom Job functions,
                    that can be executed by the API from the Worker threads. </p>

            </div>

            <div>

                <h2 id="fundamentals-objectModel"> 2.3. Object Model </h2>

                <p> The instance, jobs and meshes are represented by Mesh Loader objects. At the API level, they are referred as handles. </p>

                <p> Objects created from other objects are referred to as Child objects. The other used object is referred to as a Parent object
                    Child objects must be used only with their Parent objects, and not with other Parent objects. </p>

            </div>

            <div>

                <h2 id="fundamentals-objectLifetime"> 2.4. Object Lifetime </h2>

                <p> Objects are created or allocated by <code>MeshLoader_create*</code> or by <code>MeshLoader_allocate*</code> commands, respectively.
                    Once created, it is generally considered to be immutable, though the contents of certain object types are free to change.
                    Objects are destroyed or freed by <code>MeshLoader_destroy*</code> or by <code>MeshLoader_free*</code> commands, respectively. </p>

                <p> It is an application's responsibility to track the lifetime of MeshLoader objects, and not to destroy them while they are still in use. </p>

                <p> The ownership of application-owned memory is immediately acquired by any Mesh Loader command it is passed into. Ownership of such
                    memory <strong>must</strong> be released back to the application at the end of the duration of the command, so that the application
                    <strong>can</strong> alter or free this memory as soon as all the commands that acquired it have returned. </p>

                <div>
                    <p> While any Jobs are in the pending state, the following objects <strong> must </strong> not be destroyed </p>
                    <ul>
                        <li> <code>MeshLoader_Job</code> </li>
                    </ul>
                </div>

                <div>
                    <p> While any Jobs are in the pending state, the following objects <strong> should </strong> not be destroyed </p>
                    <ul>
                        <li> <code>MeshLoader_Instance</code> </li>
                    </ul>
                </div>

            </div>

            <div>

                <h2 id="fundamentals-applicationBinaryInterface"> 2.5. Application Binary Interface </h2>

                <p> Shared library implementations <strong>must</strong> use the default Application Binary Interface (ABI) of the standard
                    C compiler for the platform, or provide customized API headers that cause application code to use the implementation's non-default ABI. </p>
            </div>

            <div>

                <h2 id="fundamentals-commandSyntaxAndDuration"> Command Syntax and Duration </h2>

                <p> The Specification describes Mesh Loader commands and functions using C11 syntax. Language bindings may allow for stricter
                    parameter passing, or object-oriented interfaces. </p>

                <p> The following base types are used / are given aliases to be used by the implementation </p>

                <p> For 8, 16, 32 and 64-bit signed and unsigned integer types, the following type definitions are used <a id="int"></a> </p>

<pre lang="c">
typedef unsigned char                   MeshLoader_uint8;
typedef unsigned short int              MeshLoader_uint16;
typedef unsigned int                    MeshLoader_uint32;
typedef unsigned long long int          MeshLoader_uint64;

typedef signed char                     MeshLoader_sint8;
typedef signed short int                MeshLoader_sint16;
typedef signed int                      MeshLoader_sint32;
typedef signed long long int            MeshLoader_sint64;
</pre>

                <p> For 32 and 64-bit floating point types, the standard C types are used <a id="float"></a> </p>

<pre lang="c">
float
double
</pre>

                <p> For the boolean type, the following are defined. <a id="bool"></a> </p>

<pre lang="c">
typedef MeshLoader_uint8                MeshLoader_bool;
#define MeshLoader_true                 0x01U
#define MeshLoader_false                0x00U
</pre>

                <ul>
                    <li> <code>MeshLoader_true</code> is a constant representing MeshLoader_bool <strong>True</strong> value </li>
                    <li> <code>MeshLoader_false</code> is a constant representing MeshLoader_bool <strong>False</strong> value </li>
                </ul>

                <p> For representing sizes and address values, the following type is defined. <a id="size"></a> </p>

<pre lang="c">
typedef MeshLoader_uint64               MeshLoader_size;
</pre>

                <p> For representing UTF-8 formatted constant strings, the following type is defined. <a id="string"></a> </p>

<pre lang="c">
typedef char const *                    MeshLoader_StringLiteral;
</pre>

            </div>

            <div>

                <h2 id="fundamentals-validUsage">2.7. Valid Usage</h2>

                <div>

                    <h3 id="fundamentals-validUsage-explicitValidUsage">2.7.1. Explicit Valid Usage</h3>

                    <p> Explicit Valid Usage defines a set of conditions which <strong>must</strong> be met in order to achieve well-defined runtime behavior in
                        an application. These conditions depend only on the Mesh Loader state, and the parameters of objects whose usage is constrained by
                        the condition. </p>

                    <p> The core layer assumes applications are using the API correctly. Except as documented, the behavior of the core layer to an application
                        using the API incorrectly is undefined, and <strong>may</strong> include program termination. </p>

                    <p> Explicit Valid Usage are described in a block labelled "Valid Usage" following each command or structure they apply to. </p>

                </div>

                <div>

                    <h3 id="fundamentals-validUsage-implicitValidUsage">2.7.2. Implicit Valid Usage</h3>

                    <p> Some valid usage conditions apply to all commands and structures in the API, unless explicitly denoted otherwise for a specific
                    command or structure. These conditions are considered <i>implicit</i>, and are described in a block labelled "Valid Usage (Implicit)"
                        following each command or structure they apply to. </p>

                    <p> Implicit valid usage conditions: </p>

                    <ul>
                        <li>
                            <h4> Valid Usage for Object Handles: </h4>

                            <p> Any input parameter to a command that is an object handle <strong>must</strong> be a valid object handle, unless
                                otherwise specified. An object handle is valid if: </p>

                            <ul>
                                <li> It has been created or allocated by a previous, successful call to the API. Such calls are noted in the Specification. </li>
                                <li> It has not been deleted or freed by a previous call to the API. Such calls are noted in the Specification. </li>
                                <li> Any objects used by that object, either as part of creation or execution, <strong>must</strong> also be valid. </li>
                            </ul>

                            <p> The reserved values <code>MeshLoader_invalidHandle</code>, <code>NULL</code> in C or <code>nullptr</code> in C++ can
                                be used in place of handles, when explicitly called out in the Specification. Any command that creates an object successfully
                                <strong> must </strong> not return these values. It is valid to pass these values to <code>MeshLoader_destroy*</code> or
                                <code>MeshLoader_free*</code> commands, which will ignore these values. </p>
                        </li>

                        <li>
                            <h4> Valid Usage for Pointers: </h4>
                            <p> Any parameter that is a pointer <strong> must </strong> be a <i> valid pointer </i> only if it explicitly called out by a Valid Usage
                                statement. </p>
                            <p> A pointer is "valid" if it points at memory containing values of the number and type(s) expected by the command, and all
                                the fundamental types accessed through the pointer satisfy the alignment requirements of the host processor. </p>
                        </li>

                        <li>
                            <h4> Valid Usage for Strings: </h4>
                            <p> Any parameter that is a pointer to char, or of type <code>MeshLoader_StringLiteral</code> <strong>must</strong> be a finite
                                sequence of values terminated by a null character, or if explicitly called out in the Specification, <strong>can</strong> be <code>NULL</code>. </p>
                        </li>

                        <li>
                            <h4> Valid Usage for Enumerated Types: </h4>
                            <p> Any parameter of an enumerated type <strong>must</strong> be a valid enumerant for that type. An enumerant is valid if: </p>
                            <ul>
                                <li> The enumerant is defined as part of the enumerated type. </li>
                            </ul>
                        </li>

                        <li>
                            <h4> Valid Usage for Flags </h4>
                            <p> A collection of flags is represented by a bitmask using the type <code> MeshLoader_flags </code> </p>

                            <a id="flags"></a>

<pre lang="c">
typedef MeshLoader_uint32               MeshLoader_Flags;
</pre>

                            <p> Bitmasks are passed to many commands and structures to compactly represent options, but MeshLoader_Flags is not
                                used directly in the API. Instead, a <code>MeshLoader_*Flags</code> type which is an alias for <code>MeshLoader_Flags</code>, and
                                whose name matches with the corresponding <code>MeshLoader_*FlagBits</code> that are valid for that type, is used. </p>

                            <p> Any <code>MeshLoader_*Flags</code> member or parameter used in the API as an input <strong>must</strong> be a valid combination
                                of bit flags. A valid combination is either zero or the bitwise OR of valid bit flags. A bit flag is valid if: </p>

                            <ul>
                                <li>
                                    The bit flag is defined as part of the <code>MeshLoader_*FlagBits</code> type, where the bits type is obtained by taking
                                    the flag type and replacing the trailing <code>Flags</code> with <code>FlagBits</code>. For example, a flag value of type
                                    <a href="#MeshLoader_MeshLoadModeFlags">MeshLoader_MeshLoadModeFlags</a> <strong>must</strong> contain only bit flags defined by
                                    <a href="#MeshLoader_MeshLoadModeFlagBits">MeshLoader_MeshLoadModeFlagBits</a>.
                                </li>
                            </ul>

                            <p> Only the low-order 31 bits ( bit positions zero through 30 ) are available for use as flag bits. </p>
                        </li>

                        <li>
                            <h4> Valid Usage for Structure Types: </h4>
                            <p> Any parameter that is a structure containing a <code>structureType</code> member <strong>must</strong> have a value
                                of <code>structureType</code> which is a valid <a href="#MeshLoader_StructureType">MeshLoader_StructureType</a> value matching
                                the type of the structure. </p>
                        </li>

                        <li>
                            <h4> Valid Usage for Structure Pointer Chains: </h4>

                            <p> Any parameter that is a structure containing a <code>void * pNext</code> member <strong>must</strong> have a value of
                                <code>pNext</code> that is either <code>NULL</code>, or is a pointer to a valid <i>extending structure</i>, containing
                                <code>structureType</code> and <code>pNext</code>, in this order, as the first two members, aligned at 8 bytes. </p>

                            <p> Each type of extended structure <strong>must</strong> not appear more than once in a <code>pNext</code> chain, including
                                any aliases. This general rule may be explicitly overridden for specific structures. </p>
                            <p> Any component of the implementation <strong>must</strong> skip over, without processing any extending structure in the
                                chain that are not defined by the core interface component. </p>
                            <p> As a convenience to implementations and layers needing to iterate through a structure pointer chain, the API provides two
                                <i>base structure</i>. These structures allow for some type safety, and can be used by the API functions that operate on generic
                                inputs and outputs: </p>

                            <ul>
                                <li>

                                    <p> The <code>MeshLoader_BaseInStructure</code> is defined as: <a id="MeshLoader_BaseInStructure"></a> </p>

<pre lang="c">
typedef struct MeshLoader_BaseInStructure {
    MeshLoader_StructureType                    structureType;
    struct MeshLoader_BaseInStructure   const * pNext;
} MeshLoader_BaseInStructure;
</pre>

                                    <ul>
                                        <li> <code>structureType</code> is the structure type of the structure being iterated through. </li>
                                        <li> <code>pNext</code> is <code>NULL</code> or a pointer to the next structure in the structure chain. </li>
                                    </ul>

                                    <p> The <code>MeshLoader_BaseInStructure</code> can be used to facilitate iterating through a read-only structure pointer chain. </p>
                                </li>

                                <li>

                                    <p> The <code>MeshLoader_BaseOutStructure</code> is defined as: <a id="MeshLoader_BaseOutStructure"></a> </p>

<pre lang="c">
typedef struct MeshLoader_BaseOutStructure {
    MeshLoader_StructureType                    structureType;
    struct MeshLoader_BaseOutStructure        * pNext;
} MeshLoader_BaseOutStructure;
</pre>

                                    <ul>
                                        <li> <code>structureType</code> is the structure type of the structure being iterated through. </li>
                                        <li> <code>pNext</code> is <code>NULL</code> or a pointer to the next structure in the structure chain. </li>
                                    </ul>

                                    <p> The <code>MeshLoader_BaseOutStructure</code> can be used to facilitate iterating through structure pointer chain that returns
                                        data back to the application. </p>

                                </li>

                            </ul>
                        </li>

                        <li>
                            <h4> Valid Usage for Nested Structures: </h4>

                            <p> The above conditions apply recursively to members of structures provided as input to a command, either as a direct
                                argument to the command, or themselves a member of another structure. </p>

                            <p> Specifics on valid usage of each command are covered in their individual sections. </p>

                        </li>

                    </ul>
                </div>

            </div>

            <div>

                <h2 id="fundamentals-returnCodes"> 2.8. MeshLoader_Result Return Codes </h2>

                <p> While the core Mesh Loader API is not designed to capture incorrect usage, some circumstances still require return codes.
                    Commands return their status via return codes that are one in two categories: </p>

                <ul>
                    <li> Successful completion codes are returned when a command needs to communicate success or status information. All successful completion codes are non-negative values. </li>
                    <li> Run time error codes are returned when a command needs to communicate a failure that could only be detected at runtime. All runtime error codes are negative values. </li>
                </ul>

                <p> All return codes in the Mesh Loader library are reported via <a href="#MeshLoader_Result">MeshLoader_Result</a> return values. The possible codes are: </p>
                <a id="MeshLoader_Result"></a>

<pre lang="c">
typedef enum {
    MeshLoader_Result_Success                       = 0,
    MeshLoader_Result_NotReady                      = 1,
    MeshLoader_Result_TooSmall                      = 2,
    MeshLoader_Result_JobNotStarted                 = 3,
    MeshLoader_Result_ErrorUnknown                  = -1,
    MeshLoader_Result_IllegalArgument               = -2,
    MeshLoader_Result_TooManyObjects                = -3,
    MeshLoader_Result_OutOfMemory                   = -4,
    MeshLoader_Result_MutexError                    = -5,
    MeshLoader_Result_PriorityQueueEmpty            = -6,
    MeshLoader_Result_PriorityQueueFull             = -7,
    MeshLoader_Result_ResourceNotFound              = -8,
    MeshLoader_Result_JobExecutionFailed            = -9,
} MeshLoader_Result;
</pre>

                <a id="successCodes"></a>
                <p> Success Codes </p>
                <ul>
                    <li> <code>MeshLoader_Result_Success</code> - Command successfully completed. </li>
                    <li> <code>MeshLoader_Result_NotReady</code> - An operation has not been yet completed. </li>
                    <li> <code>MeshLoader_Result_TooSmall</code> - A return array was too small for the result. </li>
                    <li> <code>MeshLoader_Result_JobNotStarted</code> - A job that should be in Running or Higher state is only in Ready state. </li>
                </ul>

                <a id="errorCodes"></a>
                <p> Error Codes </p>
                <ul>
                    <li> <code>MeshLoader_Result_ErrorUnknown</code> - An unknown error has occurred; either the application has provided invalid input, or an implementation failure has occurred. </li>
                    <li> <code>MeshLoader_Result_IllegalArgument</code> - An argument passed to an API call violates the Valid Usage (Implicit) section of the respective call. This code <strong>must</strong> not be returned by a release variant library. </li>
                    <li> <code>MeshLoader_Result_TooManyObjects</code> - Too many objects of the type have already been created. </li>
                    <li> <code>MeshLoader_Result_OutOfMemory</code> - A memory allocation has failed. This <strong>must</strong> only be returned if no attempt to allocate the memory was made to accommodate the new allocation. </li>
                    <li> <code>MeshLoader_Result_MutexError</code> - The implementation failed to acquire exclusive access to a resource. This <strong>must</strong> not be returned by a release variant library. </li>
                    <li> <code>MeshLoader_Result_PriorityQueueEmpty</code> - The implementation failed to remove an element from an implementation Priority Queue. This <strong>must</strong> not be returned by a release variant library. </li>
                    <li> <code>MeshLoader_Result_PriorityQueueFull</code> - The implementation failed to add an element to an implementation Priority Queue. This <strong>must</strong> not be returned by a release variant library. </li>
                    <li> <code>MeshLoader_Result_ResourceNotFound</code> - A given resource could not be located by the implementation. This can be applied extensively, such as when an invalid path is given. This <strong>must</strong> not be returned by a release variant library.</li>
                    <li> <code>MeshLoader_Result_JobExecutionFailed</code> - A job failed during runtime execution, and was detected at this function call. </li>
                </ul>

            </div>

            <div>

                <h2 id="fundamentals-structureTypes">2.9. Structure Types</h2>

                <p> Each value corresponds to a particular structure with a <code>structureType</code> member with a matching name. As a general rule,
                    the name of each <a href="#MeshLoader_StructureType">MeshLoader_StructureType</a> value is obtained by taking the name of the structure, and adding
                    <code>_StructureType</code> between the <code>MeshLoader</code> and <code>_StructureName</code>. An example would be for the structure
                    <code>MeshLoader_JobsStartInfo</code>, whose associated <a href="#MeshLoader_StructureType">MeshLoader_StructureType</a> enumerant is
                    <code>MeshLoader_StructureType_JobsStartInfo</code>. The <code>structureType</code> must equal the enumerant's value when passed to the API. </p>

                <p> Structure types supported are described by the following:
                    <a id="MeshLoader_StructureType"></a> </p>

<pre lang="c">
typedef enum {
    MeshLoader_StructureType_Unknown                = 0x00000000U,

    MeshLoader_StructureType_AllocationCallbacks    = 0x00000001U,

    MeshLoader_StructureType_InstanceCreateInfo     = 0x00000002U,

    MeshLoader_StructureType_JobsCreateInfo         = 0x00000003U,
    MeshLoader_StructureType_JobsStartInfo          = 0x00000004U,
    MeshLoader_StructureType_JobsPauseInfo          = 0x00000005U,
    MeshLoader_StructureType_JobsResumeInfo         = 0x00000006U,
    MeshLoader_StructureType_JobsStopInfo           = 0x00000007U,
    MeshLoader_StructureType_JobsTerminateInfo      = 0x00000008U,
    MeshLoader_StructureType_JobsQueryInfo          = 0x00000009U,

    MeshLoader_StructureType_CreateJobInfo          = 0x00000010U,
    MeshLoader_StructureType_QueryJobInfo           = 0x0000000AU,

    MeshLoader_StructureType_AllocationNotification = 0x0000000CU,

    MeshLoader_StructureType_JobData                = 0x00001000U,
    MeshLoader_StructureType_CustomJobInfo          = 0x00001001U,

    MeshLoader_StructureType_MeshData               = 0x0000000BU,
} MeshLoader_StructureType;
</pre>

            </div>

        </div>

        <div>

            <h1 id="instances">3. Instances</h1>

            <p> In order to use the library, an instance has to be created. There is no global state for the library. All objects are created from instances. </p>
            <p> Instances are represented by <code>MeshLoader_Instance</code> handles: </p>

            <a id="MeshLoader_Instance"></a>

<pre lang="c">
MESH_LOADER_DEFINE_HANDLE ( MeshLoader_Instance )
</pre>

            <div>

                <h2 id="instances-instanceCreation">3.1. Instance Creation</h2>

                <p> To create an instance object, call: </p>
                <a id="MeshLoader_createInstance"></a>

<pre lang="c">
MeshLoader_Result MeshLoader_createInstance (
    MeshLoader_InstanceCreateInfo   const * pCreateInfo,
    MeshLoader_AllocationCallbacks  const * pAllocationCallbacks,
    MeshLoader_Instance                   * pInstance
);
</pre>

                <ul>
                    <li> <code>pCreateInfo</code> is a pointer to a <a href="#MeshLoader_InstanceCreateInfo">MeshLoader_InstanceCreateInfo</a> structure controlling the creation of the instance</li>
                    <li> <code>pAllocationCallbacks</code> controls memory allocation as described in the <a href="#memoryAllocation">Memory Allocation</a> chapter. </li>
                    <li> <code>pInstance</code> points to a <a href="#MeshLoader_Instance">MeshLoader_Instance</a> handle in which the resulting instance is returned. </li>
                </ul>

                <h3> Valid Usage (Implicit)</h3>

                <ul>
                    <li> <small> MLUID-MeshLoader_createInstance-pCreateInfo-parameter </small> <br/>
                        <code>pCreateInfo</code> <strong>must</strong> be a valid pointer to a valid <a href="#MeshLoader_InstanceCreateInfo">MeshLoader_InstanceCreateInfo</a> structure
                    </li>
                    <li> <small> MLUID-MeshLoader_createInstance-pAllocationCallbacks-parameter </small> <br/>
                        If <code>pAllocationCallbacks</code> is not <code>NULL</code>, <code>pAllocationCallbacks</code> <strong>must</strong> be a valid pointer to a valid <a href="#MeshLoader_AllocationCallbacks">MeshLoader_AllocationCallbacks</a> structure
                    </li>
                    <li> <small> MLUID-MeshLoader_createInstance-pInstance-parameter </small> <br/>
                        <code>pInstance</code> <strong>must</strong> be a valid pointer to a <a href="#MeshLoader_Instance">MeshLoader_Instance</a> handle
                    </li>
                </ul>

                <h3> Return Codes </h3>
                <a href="#successCodes">Success</a>
                <ul>
                    <li> <code>MeshLoader_Result_Success</code> </li>
                </ul>
                <a href="#errorCodes">Failure</a>
                <ul>
                    <li> <code>MeshLoader_Result_OutOfMemory</code> </li>
                    <li> <code>MeshLoader_Result_MutexError</code> </li>
                </ul>

                <p> The <code>MeshLoader_InstanceCreateInfo</code> structure is defined as: </p>
                <a id="MeshLoader_InstanceCreateInfo"></a>

<pre lang="c">
typedef struct {
    MeshLoader_StructureType            structureType;
    void                        const * pNext;
    MeshLoader_InstanceCreateFlags      flags;
    MeshLoader_uint32                   maxWorkerThreadCount;
} MeshLoader_InstanceCreateInfo;
</pre>

                <ul>
                    <li> <code>structureType</code> is the type of the structure. </li>
                    <li> <code>pNext</code> is <code>NULL</code> or a pointer to a structure extending this structure. </li>
                    <li> <code>flags</code> is reserved for future use. </li>
                    <li> <code>maxWorkerThreadCount</code> is the maximum number of threads the Instance is allowed to use for Worker Thread objects. If value is 0, the instance will use 1/4 of the maximum processor capable concurrent threads ( logical core count ) </li>
                </ul>

                <h3> Valid Usage (Implicit) </h3>
                <ul>
                    <li> <small> MLUID-MeshLoader_InstanceCreateInfo-structureType </small> <br/>
                        <code>structureType</code> <strong>must</strong> be <code>MeshLoader_StructureType_InstanceCreateInfo</code>
                    </li>
                    <li> <small> MLUID-MeshLoader_InstanceCreateInfo-pNext </small> <br/>
                        <code>pNext</code> <strong>must</strong> be <code>NULL</code>
                    </li>
                    <li> <small> MLUID-MeshLoader_InstanceCreateInfo-flags-parameter </small> <br/>
                        <code>flags</code> <strong>must</strong> be <code>0</code>
                    </li>
                </ul>

                <a id="MeshLoader_InstanceCreateFlags"></a>
                <p> The <code>MeshLoader_InstanceCreateFlags</code> type is reserved for future use. </p>

<pre lang="c">
typedef MeshLoader_Flags                MeshLoader_InstanceCreateFlags;
</pre>

            </div>

            <div>

                <h2 id="instances-instanceDestruction"> 3.2. Instance Destruction </h2>

                <p> To destroy an instance, call: </p>
                <a id="MeshLoader_destroyInstance"></a>

<pre lang="c">
void MeshLoader_destroyInstance (
    MeshLoader_Instance                     instance,
    MeshLoader_AllocationCallbacks  const * pAllocationCallbacks
);
</pre>

                <ul>
                    <li> <code>instance</code> is the handle of the instance to destroy </li>
                    <li> <code>pAllocationCallbacks</code> controls memory allocation as described in the <a href="#memoryAllocation">Memory Allocation</a> chapter. </li>
                </ul>

                <h3> Valid Usage </h3>
                <ul>
                    <li> <small> MLUID-MeshLoader_destroyInstance-instance-00001 </small> <br/>
                        All child objects created using <code>instance</code> <strong>must</strong> have been destroyed prior to this call.
                    </li>
                    <li> <small> MLUID-MeshLoader_destroyInstance-instance-00002 </small> <br/>
                        If <code>MeshLoader_AllocationCallbacks</code> were provided when <code>instance</code> was created, a compatible set of
                        callbacks <strong>must</strong> be provided as a parameter for this call.
                    </li>
                    <li> <small> MLUID-MeshLoader_destroyInstance-instance-00003 </small> <br/>
                        If no <code>MeshLoader_AllocationCallbacks</code> were provided when <code>instance</code> was created, <code>pAllocationCallbacks</code> <strong>must</strong> be <code>NULL</code>.
                    </li>
                </ul>

                <h3> Valid Usage (Implicit) </h3>
                <ul>
                    <li> <small> MLUID-MeshLoader_destroyInstance-instance-parameter </small> <br/>
                        If <code>instance</code> is not <code>NULL</code>, <code>instance</code> <strong>must</strong> be a valid <a href="#MeshLoader_Instance">MeshLoader_Instance</a>
                        handle.
                    </li>
                    <li> <small> MLUID-MeshLoader_destroyInstance-pAllocationCallbacks-parameter </small> <br/>
                        If <code>pAllocationCallbacks</code> is not <code>NULL</code>, <code>pAllocationCallbacks</code> <strong>must</strong> be a valid pointer to a valid
                        <a href="#MeshLoader_AllocationCallbacks">MeshLoader_AllocationCallbacks</a> structure.
                    </li>
                </ul>

            </div>

        </div>

        <div>

            <h1 id="jobs">4. Jobs</h1>

            <p> A Job is a description of the task that has to be computed in the background by the library in order to load a single object.
                Once created, it has to be started, and the result can be observed or fully acquired from it. The job type determines the
                task that the Worker Thread will execute in order to load the requested file. </p>

            <p> The job types can be expanded by creating <a href="#userDefinedJobs">User Defined Jobs</a>. </p>

            <p> Jobs are created using an instance, and are Child objects to the used Instance. The application <strong>must</strong>, as a result,
                destroy all jobs created from an instance before destroying an instance. </p>

            <p> Jobs are represented by <code>MeshLoader_Job</code> handles:
                <a id="MeshLoader_Job"></a> </p>

<pre lang="c">
MESH_LOADER_DEFINE_HANDLE ( MeshLoader_Job )
</pre>

            <div>

                <h2 id="jobs-jobLifetimeAndExecution"> 4.1. Job Lifetime & Execution </h2>

                <p> Since a lot of objects have to be loaded, jobs <i>should</i> be created, started and queried in large batches. Since
                    they operate on a priority basis, there is some control over the order in which jobs will be handled and be finished. </p>

                <p> The following states are defined for a job: </p>

                <ul>
                    <li> <strong class="strong-state-description"> Ready </strong> - the job is created and awaiting launch. </li>
                    <li> <strong class="strong-state-description"> Running </strong> - the job is being treated by a Worker or is waiting for a Worker to handle it. </li>
                    <li> <strong class="strong-state-description"> Paused </strong> - the job is not being treated by any Worker and will not be picked up by one until it is resumed to Running. </li>
                    <li> <strong class="strong-state-description"> Stopped </strong> - the job is not being treated by any Worker and cannot be picked up anymore until it is restarted, or is destroyed. </li>
                    <li> <strong class="strong-state-description"> Terminated </strong> - the job is not being treated by any Worker and <i>should</i> not be restarted. </li>
                    <li> <strong class="strong-state-description"> Finished </strong> - the job has is finished, and its results can be observed or acquired. It can be restarted afterwards. </li>
                    <li> <strong class="strong-state-description"> FinishedError </strong> - the job has encountered an error, and must be cleared of its error state before being restarted, or just destroyed. </li>
                </ul>

                <p> The possible job states are defined by the <a href="#MeshLoader_JobState">MeshLoader_JobState</a> enumeration. </p>

                <p> The following actions are defined for interacting with a job from the API: </p>

                <ul>
                    <li> <strong class="strong-action-description"> Start </strong> - used for starting job objects execution. </li>
                    <li> <strong class="strong-action-description"> Pause </strong> - used to pause job objects execution. </li>
                    <li> <strong class="strong-action-description"> Resume </strong> - used to resume job objects execution. </li>
                    <li> <strong class="strong-action-description"> Stop </strong> - used to stop job objects execution in a safe manner. </li>
                    <li> <strong class="strong-action-description"> Terminate </strong> - used to terminate job objects execution immediately. </li>
                    <li> <strong class="strong-action-description"> Get Error </strong> - used to acquire the error that caused a job object's execution to halt. </li>
                </ul>

                <p> The possible job actions are defined by the interfaces found in <a href="#jobs-jobExecutionCommands">Job Execution Commands</a> section. </p>

                <p> State Transition Table: </p>

                <table id="jobs-stateTransitionTable">
                    <tr>
                        <th> <strong> Action/State </strong> </th>
                        <th> <strong class="strong-state-description"> Ready </strong> </th>
                        <th> <strong class="strong-state-description"> Running </strong> </th>
                        <th> <strong class="strong-state-description"> Paused </strong> </th>
                        <th> <strong class="strong-state-description"> Stopped </strong> </th>
                        <th> <strong class="strong-state-description"> Terminated </strong> </th>
                        <th> <strong class="strong-state-description"> Finished </strong> </th>
                        <th> <strong class="strong-state-description"> Finished Error </strong> </th>
                    </tr>
                    <tr>
                        <th> <strong class="strong-action-description"> Start </strong> </th>
                        <td> <strong class="strong-state-description">Running</strong> </td>
                        <td> <strong class="strong-state-description">Running</strong> </td>
                        <td> <i> undefined </i></td>
                        <td> <strong class="strong-state-description">Running</strong> </td>
                        <td> <i> undefined </i> </td>
                        <td> <strong class="strong-state-description">Running</strong> </td>
                        <td> <i> undefined </i> </td>
                    </tr>
                    <tr>
                        <th> <strong class="strong-action-description"> Pause </strong> </th>
                        <td> <i> undefined </i> </td>
                        <td> <strong class="strong-state-description">Paused</strong> </td>
                        <td> <strong class="strong-state-description">Paused</strong> </td>
                        <td> <strong class="strong-state-description">Stopped</strong> </td>
                        <td> <i> undefined </i> </td>
                        <td> <strong class="strong-state-description">Finished</strong> </td>
                        <td> <i> undefined </i> </td>
                    </tr>
                    <tr>
                        <th> <strong class="strong-action-description">Resume</strong> </th>
                        <td> <strong class="strong-state-description">Ready</strong> </td>
                        <td> <strong class="strong-state-description">Running</strong> </td>
                        <td> <strong class="strong-state-description">Running</strong> </td>
                        <td> <strong class="strong-state-description">Stopped</strong> </td>
                        <td> <i> undefined </i> </td>
                        <td> <strong class="strong-state-description">Finished</strong> </td>
                        <td> <i> undefined </i> </td>
                    </tr>
                    <tr>
                        <th> <strong class="strong-action-description">Stop</strong> </th>
                        <td> <strong class="strong-state-description">Ready</strong> </td>
                        <td> <strong class="strong-state-description">Stopped</strong> </td>
                        <td> <strong class="strong-state-description">Stopped</strong> </td>
                        <td> <strong class="strong-state-description">Stopped</strong> </td>
                        <td> <i> undefined </i> </td>
                        <td> <strong class="strong-state-description">Finished</strong> </td>
                        <td> <i> undefined </i> </td>
                    </tr>
                    <tr>
                        <th> <strong class="strong-action-description">Terminate</strong> </th>
                        <td> <strong class="strong-state-description">Terminated</strong> </td>
                        <td> <strong class="strong-state-description">Terminated</strong> </td>
                        <td> <strong class="strong-state-description">Terminated</strong> </td>
                        <td> <strong class="strong-state-description">Terminated</strong> </td>
                        <td> <i> undefined </i> </td>
                        <td> <strong class="strong-state-description">Terminated</strong> </td>
                        <td> <strong class="strong-state-description">Terminated</strong> </td>
                    </tr>
                    <tr>
                        <th> <strong class="strong-action-description">Get Error</strong> </th>
                        <td> <strong class="strong-state-description">Ready</strong> </td>
                        <td> <strong class="strong-state-description">Running</strong> </td>
                        <td> <strong class="strong-state-description">Paused</strong> </td>
                        <td> <strong class="strong-state-description">Stopped</strong> </td>
                        <td> <i> undefined </i> </td>
                        <td> <strong class="strong-state-description">Finished</strong> </td>
                        <td> <strong class="strong-state-description">Ready</strong> </td>
                    </tr>
                </table>

                <ul>
                    <li>
                        <p> An <i>undefined</i> state transition entry in the table represents an incompatible <strong>Action/State</strong> transition. Triggering the
                            <strong class="strong-action-description">defined action</strong> (row header) for a job while it's state is the
                            <strong class="strong-state-description">defined state</strong> (column header) results in undefined behaviour. </p>
                        <p> An example would be
                            triggering <strong class="strong-state-description">Pause</strong> on a job that is <strong class="strong-state-description">Ready</strong> is undefined behaviour, since the job has not even been started,
                            and the implementation does not specify any behaviour for this transition. The job this action is triggered on could remain in the <strong class="strong-state-description">Ready</strong>
                            state, or transition to the <strong class="strong-state-description">Paused</strong> state. </p>
                    </li>
                    <li>
                        <p> The <strong class="strong-state-description">Terminated</strong> state <strong>must</strong> not have any actions triggered upon it, and <strong>must</strong> only be destroyed.</p>
                    </li>
                </ul>

            </div>

            <div>

                <h2 id="jobs-jobCreation"> 4.2. Job Creation </h2>

                <p> To create a number of Job objects, call:
                    <a id="MeshLoader_createJobs"></a> </p>

<pre lang="c">
MeshLoader_Result MeshLoader_createJobs (
    MeshLoader_Instance                     instance,
    MeshLoader_JobsCreateInfo       const * pCreateInfo,
    MeshLoader_AllocationCallbacks  const * pAllocationCallbacks
);
</pre>

                <ul>
                    <li> <code>instance</code> is a handle of a <i>valid</i> <a href="#MeshLoader_Instance">MeshLoader_Instance</a> handle previously created with <a href="#MeshLoader_createInstance">MeshLoader_createInstance</a>. </li>
                    <li> <code>pCreateInfo</code> is a pointer to a <a href="#MeshLoader_JobsCreateInfo">MeshLoader_JobsCreateInfo</a> structure controlling the creation of this batch of jobs. </li>
                    <li> <code>pAllocationCallbacks</code> controls memory allocation as described in the <a href="#memoryAllocation">Memory Allocation</a> chapter. </li>
                </ul>

                <h3> Valid Usage (Implicit) </h3>
                <ul>
                    <li> <small> MLUID-MeshLoader_createJobs-instance-parameter </small> <br/>
                        <code>instance</code> <strong>must</strong> be a valid <a href="#MeshLoader_Instance">MeshLoader_Instance</a> handle.
                    </li>
                    <li> <small> MLUID-MeshLoader_createJobs-pCreateInfo-parameter </small> <br/>
                        <code>pCreateInfo</code> <strong>must</strong> be a valid pointer to a valid <a href="#MeshLoader_JobsCreateInfo">MeshLoader_JobsCreateInfo</a> structure.
                    </li>
                    <li> <small> MLUID-MeshLoader_createJobs-pAllocationCallbacks-parameter </small> <br/>
                        If <code>pAllocationCallbacks</code> is not <code>NULL</code>, <code>pAllocationCallbacks</code> <strong>must</strong> be a valid pointer
                        to a valid <a href="#MeshLoader_AllocationCallbacks">MeshLoader_AllocationCallbacks</a> structure.
                    </li>
                </ul>

                <h3> Return Codes </h3>
                <a href="#successCodes">Success</a>
                <ul>
                    <li> <code>MeshLoader_Result_Success</code> </li>
                </ul>
                <a href="#errorCodes">Failure</a>
                <ul>
                    <li> <code>MeshLoader_Result_OutOfMemory</code> </li>
                    <li> <code>MeshLoader_Result_MutexError</code> </li>
                </ul>

                <p> The <code> MeshLoader_JobsCreateInfo </code> structure is defined as:
                    <a id="MeshLoader_JobsCreateInfo"></a> </p>

<pre lang="c">
typedef struct {
    MeshLoader_StructureType            structureType;
    void                        const * pNext;
    MeshLoader_JobsCreateFlags          flags;
    MeshLoader_uint32                   jobCount;
    MeshLoader_Job                    * pJobs;
    MeshLoader_CreateJobInfo    const * pCreateJobInfos;
} MeshLoader_JobsCreateInfo;
</pre>

                <ul>
                    <li> <code>structureType</code> is the type of the structure. </li>
                    <li> <code>pNext</code> is <code>NULL</code> or a pointer to a structure extending this structure. </li>
                    <li> <code>flags</code> is a bitmask of <a href="#MeshLoader_JobsCreateFlagBits">MeshLoader_JobsCreateFlagBits</a> indicating the behaviour of the batch create command. </li>
                    <li> <code>jobCount</code> is the unsigned integer count of the jobs to be created by this command. </li>
                    <li> <code>pJobs</code> is a pointer to an array of <a href="#MeshLoader_Job">MeshLoader_Job</a>, and is the memory area where the command's output will be saved, if successful. </li>
                    <li> <code>pCreateJobInfos</code> is a pointer to an array of <a href="#MeshLoader_CreateJobInfo">MeshLoader_CreateJobInfo</a> structures describing the intended behaviour of each of the jobs to be created </li>
                </ul>

                <h3> Valid Usage (Implicit) </h3>

                <ul>
                    <li> <small> MLUID-MeshLoader_JobsCreateInfo-structureType </small> <br/>
                        <code>structureType</code> <strong>must</strong> be <code>MeshLoader_StructureType_JobsCreateInfo</code>.
                    </li>
                    <li> <small> MLUID-MeshLoader_JobsCreateInfo-pNext </small> <br/>
                        <code>pNext</code> <strong>must</strong> be <code>NULL</code>.
                    </li>
                    <li> <small> MLUID-MeshLoader_JobsCreateInfo-flags-parameter </small> <br/>
                        <code>flags</code> <strong>must</strong> be a valid combination of <a href="#MeshLoader_JobsCreateFlagBits">MeshLoader_JobsCreateFlagBits</a> values.
                    </li>
                    <li> <small> MLUID-MeshLoader_JobsCreateInfo-jobCount-parameter </small> <br/>
                        <code>jobCount</code> <strong>must</strong> be greater than <code>0</code>.
                    </li>
                    <li> <small> MLUID-MeshLoader_JobsCreateInfo-pJobs-parameter </small> <br/>
                        <code>pJobs</code> <strong>must</strong> be a valid pointer to an array of <code>jobCount</code> valid <a href="#MeshLoader_Job">MeshLoader_Job</a> handles.
                    </li>
                    <li> <small> MLUID-MeshLoader_JobsCreateInfo-pCreateJobInfos-parameter </small> <br/>
                        <code>pCreateJobInfos</code> <strong>must</strong> be a valid pointer to an array of valid <code>jobCount</code> <a href="#MeshLoader_CreateJobInfo">MeshLoader_CreateJobInfo</a> structures.
                    </li>
                </ul>

                <p> Bits that can be set in <a href="#MeshLoader_JobsCreateInfo">MeshLoader_JobsCreateInfo</a><code>::flags</code>, specifying creation usage of the Jobs, are:
                    <a id="MeshLoader_JobsCreateFlagBits"></a> </p>

<pre lang="c">
typedef enum {
    MeshLoader_JobsCreateFlag_ContinueIfError       = 0x00000001U,
} MeshLoader_JobsCreateFlagBits;
</pre>

                <ul>
                    <li> <code>MeshLoader_JobsCreateFlag_ContinueIfError</code> specifies that, if a job creation fails, the other jobs will proceed to be created, and the subsequent failed creations will result
                        in a <code>NULL</code> handle stored for the respective jobs inside the <a href="#MeshLoader_JobsCreateInfo">MeshLoader_JobsCreateInfo</a><code>::pJobs</code> array. </li>
                </ul>

                <p> The bitmask type used in <a href="#MeshLoader_JobsCreateInfo">MeshLoader_JobsCreateInfo</a><code>::flags</code> is defined as follows:
                    <a id="MeshLoader_JobCreateFlags"></a> </p>

<pre lang="c">
typedef MeshLoader_Flags                MeshLoader_JobsCreateFlags;
</pre>

                <p> The <code>MeshLoader_CreateJobInfo</code> is defined as:
                    <a id="MeshLoader_CreateJobInfo"></a> </p>

<pre lang="c">
typedef struct {
    MeshLoader_StructureType            structureType;
    void                        const * pNext;
    MeshLoader_JobType                  jobType;
    MeshLoader_MeshLoadModeFlags        loadMode;
    MeshLoader_StringLiteral            inputPath;
    float                               priority;
} MeshLoader_CreateJobInfo;
</pre>

                <ul>
                    <li> <code>structureType</code> is the type of the structure. </li>
                    <li> <code>pNext</code> is <code>NULL</code> or a pointer to a structure extending this structure. </li>
                    <li> <code>jobType</code> is an enumerant value defined by <a href="#MeshLoader_JobType">MeshLoader_JobType</a>, specifying the job's type and file format. </li>
                    <li> <code>loadMode</code> is a bitmask of <a href="#MeshLoader_MeshLoadModeFlags">MeshLoader_MeshLoadModeFlags</a> indicating the load mode and operations to be done in the Job Execution. </li>
                    <li> <code>inputPath</code> is a pointer to a null-terminated UTF-8 <a href="#string">MeshLoader_StringLiteral</a> which contains the path, relative to the application or absolute, of the file that is used as input data for the job.  </li>
                    <li> <code>priority</code> is a float value specifying the priority of the Job, ranging from 0.0f (lowest) to 1.0f (highest). </li>
                </ul>

                <h3>Valid Usage</h3>

                <ul>
                    <li> <small> MLUID-MeshLoader_CreateJobInfo-pNext-00004 </small> <br/>
                        If the <code>pNext</code> chain includes a <a href="#MeshLoader_CustomJobInfo">MeshLoader_CustomJobInfo</a> structure,
                        then <code>jobType</code> <strong>must</strong> be <code>MeshLoader_JobType_Custom</code>.
                    </li>
                    <li> <small> MLUID-MeshLoader_CreateJobInfo-jobType-00005 </small> <br/>
                        If <code>jobType</code> is <code>MeshLoader_JobType_Custom</code>, the <code>pNext</code> pNext
                        structure chain <strong>must</strong> include a a <a href="#MeshLoader_CustomJobInfo">MeshLoader_CustomJobInfo</a> structure.
                    </li>
                </ul>

                <h3>Valid Usage (Implicit)</h3>

                <ul>
                    <li> <small> MLUID-MeshLoader_CreateJobInfo-structureType </small> <br/>
                        <code>structureType</code> <strong>must</strong> be <code>MeshLoader_StructureType_CreateJobInfo</code>.
                    </li>
                    <li> <small> MLUID-MeshLoader_CreateJobInfo-pNext </small> <br/>
                        Each <code>pNext</code> member of any structure (including this one) in the <code>pNext</code> chain <strong>must</strong>
                        be either <code>NULL</code> or a pointer to a valid instance of <a href="#MeshLoader_CustomJobInfo">MeshLoader_CustomJobInfo</a>.
                    </li>
                    <li> <small> MLUID-MeshLoader_CreateJobInfo-jobType-parameter </small> <br/>
                        <code>jobType</code> <strong>must</strong> be a valid enumerant defined by <a href="#MeshLoader_JobType">MeshLoader_JobType</a>
                    </li>
                    <li> <small> MLUID-MeshLoader_CreateJobInfo-loadMode-parameter </small> <br/>
                        <code>loadMode</code> <strong>must</strong> be a valid combination of <a href="#MeshLoader_MeshLoadModeFlagBits">MeshLoader_MeshLoadModeFlagBits</a> values.
                    </li>
                    <li> <small> MLUID-MeshLoader_CreateJobInfo-inputPath-parameter </small> <br/>
                        <code>inputPath</code> <strong>must</strong> be a valid pointer to a null-terminated UTF-8 string.
                    </li>
                    <li> <small>MLUID-MeshLoader_CreateJobInfo-priority-parameter </small> <br/>
                        <code>priority</code> <strong>must</strong> be greater than or equal to 0.0f and less than or equal to 1.0f.
                    </li>
                </ul>

                <p> Values that can be used to specify a Job's type are defined by
                    <code>MeshLoader_JobType</code>:
                    <a id="MeshLoader_JobType"></a> </p>

<pre lang="c">
typedef enum {
    MeshLoader_JobType_Obj                          = 0x00000000U,
    MeshLoader_JobType_Custom                       = 0x00001000U,
} MeshLoader_JobType;
</pre>

                <ul>
                    <li>
                        <code>MeshLoader_JobType_Obj</code> describes a job that requires
                        loading a Wavefront .obj file, and that will use the included library
                        loader task.
                    </li>
                    <li>
                        <code>MeshLoader_JobType_Custom</code> describes a job whose behaviour
                        is user-defined by the implementing application. A job described by this type
                        <strong>must</strong> have its behaviour specified. See more in <a href="#userDefinedJobs">User Defined Jobs</a>
                    </li>
                </ul>

                <p> The specific data that a job is expected to load and contain at finish can be mentioned using the bits described by
                    <code>MeshLoader_MeshLoadModeFlagBits</code>:
                    <a id="MeshLoader_MeshLoadModeFlagBits"></a> </p>

<pre lang="c">
typedef enum {
    MeshLoader_MeshLoadModeFlag_LoadFaces           = 0x00000001U,
    MeshLoader_MeshLoadModeFlag_LoadIndices         = 0x00000002U,
} MeshLoader_MeshLoadModeFlagBits;
</pre>

                <ul>
                    <li>
                        <code>MeshLoader_MeshLoadModeFlag_LoadFaces</code> specifies that the job <strong>must</strong> include
                        valid mesh face data.
                    </li>
                    <li>
                        <code>MeshLoader_MeshLoadModeFlag_LoadIndices</code> specifies that the job <strong>must</strong> include
                        valid mesh indices data.
                    </li>
                </ul>

                <p> The bitmask type used for specifying the load formats is defined as follows:
                    <a id="MeshLoader_MeshLoadModeFlags"></a> </p>

<pre lang="c">
typedef MeshLoader_Flags                MeshLoader_MeshLoadModeFlags;
</pre>

                <p> The specified load mode behavior will have a direct effect on what functions can be used
                    to load mesh data, once the job is finished loading. More info can be found at <a href="#meshes-readingMeshData">Reading Mesh Data</a>. </p>

            </div>

            <div>

                <h2 id="jobs-jobExecutionCommands"> 4.3. Job Execution Commands </h2>

                <p> To start a batch of jobs, call:
                    <a id="MeshLoader_startJobs"></a> </p>

<pre lang="c">
MeshLoader_Result MeshLoader_startJobs (
        MeshLoader_Instance                     instance,
        MeshLoader_JobsStartInfo        const * pStartInfo
);
</pre>

                <ul>
                    <li> <code>instance</code> is a handle of a <i>valid</i> <a href="#MeshLoader_Instance">MeshLoader_Instance</a> handle previously created with <a href="#MeshLoader_createInstance">MeshLoader_createInstance</a>. </li>
                    <li> <code>pStartInfo</code> is a pointer to a <a href="#MeshLoader_JobsStartInfo">MeshLoader_JobsStartInfo</a> structure controlling the execution behaviour of the jobs. </li>
                </ul>

                <h3> Valid Usage </h3>
                <ul>
                    <li> <small> MLUID-MeshLoader_startJobs-jobStates-00006 </small> <br/>
                        All job handles contained in the array given through the <code>pJobs</code> pointer in the structure at <code>pStartInfo</code> <strong>must</strong>
                        be in a state that is compatible with the start operation, as defined by the <a href="#jobs-stateTransitionTable">State Transition Table</a>.
                    </li>
                    <li> <small> MLUID-MeshLoader_startJobs-pAllocationCallbacks-00007 </small> <br/>
                        If <code>pAllocationCallbacks</code> in the structure at <code>pStartInfo</code> is not <code>NULL</code>, the elements contained within the given <a href="#MeshLoader_AllocationCallbacks">MeshLoader_AllocationCallbacks</a>
                        <strong>must</strong> remain available after call using this structure is complete, until the Jobs started by the call have destroyed.
                    </li>
                </ul>

                <h3> Valid Usage (Implicit) </h3>
                <ul>
                    <li> <small> MLUID-MeshLoader_startJobs-instance-parameter </small> <br/>
                        <code>instance</code> <strong>must</strong> be a valid <a href="#MeshLoader_Instance">MeshLoader_Instance</a> handle.
                    </li>
                    <li> <small> MLUID-MeshLoader_startJobs-pCreateInfo-parameter </small> <br/>
                        <code>pStartInfo</code> <strong>must</strong> be a valid pointer to a valid <a href="#MeshLoader_JobsStartInfo">MeshLoader_JobsStartInfo</a> structure.
                    </li>
                </ul>

                <h3> Return Codes </h3>
                <a href="#successCodes">Success</a>
                <ul>
                    <li> <code>MeshLoader_Result_Success</code> </li>
                </ul>
                <a href="#errorCodes">Failure</a>
                <ul>
                    <li> <code>MeshLoader_Result_OutOfMemory</code> </li>
                    <li> <code>MeshLoader_Result_MutexError</code> </li>
                </ul>

                <p> The <code>MeshLoader_JobsStartInfo</code> structure is defined as follows:
                    <a id="MeshLoader_JobsStartInfo"></a> </p>

<pre lang="c">
typedef struct {
    MeshLoader_StructureType                structureType;
    void                            const * pNext;
    MeshLoader_JobsStartFlags               flags;
    MeshLoader_uint32                       jobCount;
    MeshLoader_Job                  const * pJobs;
    MeshLoader_AllocationCallbacks  const * pAllocationCallbacks;
} MeshLoader_JobsStartInfo;
</pre>

                <ul>
                    <li> <code>structureType</code> is the type of the structure. </li>
                    <li> <code>pNext</code> is <code>NULL</code> or a pointer to a structure extending this structure. </li>
                    <li> <code>flags</code> is reserved for future use. </li>
                    <li> <code>jobCount</code> is an unsigned integer specifying the number of Jobs that are to be started. </li>
                    <li> <code>pJobs</code> is a pointer to an array of <i>valid</i> <a href="#MeshLoader_Job">MeshLoader_Job</a> handles,
                        previously created with <a href="#MeshLoader_createJobs">MeshLoader_createJobs</a>. The jobs associated to the given handles are to be started. </li>
                    <li> <code>pAllocationCallbacks</code> is a pointer to a <a href="#MeshLoader_AllocationCallbacks">MeshLoader_AllocationCallbacks</a> structure. This controls
                        the memory allocation handled by the Worker Threads when processing this job, as described in the <a href="#memoryAllocation">Memory Allocation</a> chapter.</li>
                </ul>

                <h3>Valid Usage (Implicit)</h3>

                <ul>
                    <li> <small> MLUID-MeshLoader_JobsStartInfo-structureType </small> <br/>
                        <code>structureType</code> <strong>must</strong> be <code>MeshLoader_StructureType_JobsStartInfo</code>.
                    </li>
                    <li> <small> MLUID-MeshLoader_JobsStartInfo-pNext </small> <br/>
                        <code>pNext</code> must be <code>NULL</code>.
                    </li>
                    <li> <small> MLUID-MeshLoader_JobsStartInfo-flags-parameter </small> <br/>
                        <code>flags</code> <strong>must</strong> be <code>0</code>.
                    </li>
                    <li> <small> MLUID-MeshLoader_JobsStartInfo-jobCount-parameter </small> <br/>
                        <code>jobCount</code> <strong>must</strong> be greater than <code>0</code>.
                    </li>
                    <li> <small> MLUID-MeshLoader_JobsStartInfo-pJobs-parameter </small> <br/>
                        <code>pJobs</code> <strong>must</strong> be a valid pointer to an array of <code>jobCount</code> <i>valid</i> <a href="#MeshLoader_Job">MeshLoader_Job</a> handles.
                    </li>
                    <li> <small> MLUID-MeshLoader_JobsStartInfo-pAllocationCallbacks-parameter </small> <br/>
                        If <code>pAllocationCallbacks</code> is not <code>NULL</code>, <code>pAllocationCallbacks</code> <strong>must</strong> be a valid pointer to a valid <a href="#MeshLoader_AllocationCallbacks">MeshLoader_AllocationCallbacks</a> structure.
                    </li>
                </ul>

                <p> To pause a job, call:
                    <a id="MeshLoader_pauseJob"></a>
                    To be added </p>

                <p> To resume a job, call:
                    <a id="MeshLoader_resumeJob"></a>
                    To be added </p>

                <p> To stop a job, call:
                    <a id="MeshLoader_stopJob"></a>
                    To be added </p>

                <p> To terminate a job, call:
                    <a id="MeshLoader_terminateJob"></a>
                    To be added </p>

                <p> To get the error of a job, call:
                    <a id="MeshLoader_getJobError"></a>
                    To be added </p>

            </div>

            <div>

                <h2 id="jobs-queryingJobStatus"> 4.4. Querying Job Status </h2>

                <p> To query the status of a batch of jobs, call:
                    <a id="MeshLoader_queryJobs"></a> </p>

<pre lang="c">
MeshLoader_Result MeshLoader_queryJobs (
    MeshLoader_Instance                     instance,
    MeshLoader_JobsQueryInfo              * pQueryInfo
);
</pre>
                <ul>
                    <li> <code>instance</code> is a handle of a <i>valid</i> <a href="#MeshLoader_Instance">MeshLoader_Instance</a> handle previously created with <a href="#MeshLoader_createInstance">MeshLoader_createInstance</a>. </li>
                    <li> <code>pQueryInfo</code> is a pointer to a <a href="#MeshLoader_JobsQueryInfo">MeshLoader_JobsQueryInfo</a> structure containing the query data. </li>
                </ul>

                <h3>Valid Usage</h3>
                <ul>
                    <li> <small> MLUID-MeshLoader_queryJobs-validJobIDS-00008 </small> <br/>
                        All job handles given in the <code>job</code> field of each <a href="#MeshLoader_QueryJobInfo">MeshLoader_QueryJobInfo</a> given to
                        <code>pQueryJobInfos</code> must be a <i>valid</i> <a href="#MeshLoader_Job">MeshLoader_Job</a> created previously in a
                        <a href="#MeshLoader_createJobs">MeshLoader_createJobs</a> call.
                    </li>
                </ul>

                <h3> Valid Usage (Implicit) </h3>
                <ul>
                    <li> <small> MLUID-MeshLoader_startJobs-instance-parameter </small> <br/>
                        <code>instance</code> <strong>must</strong> be a valid <a href="#MeshLoader_Instance">MeshLoader_Instance</a> handle.
                    </li>
                    <li> <small> MLUID-MeshLoader_startJobs-pCreateInfo-parameter </small> <br/>
                        <code>pQueryInfo</code> <strong>must</strong> be a valid pointer to a valid <a href="#MeshLoader_JobsQueryInfo">MeshLoader_JobsQueryInfo</a> structure.
                    </li>
                </ul>

                <h3> Return Codes </h3>
                <a href="#successCodes">Success</a>
                <ul>
                    <li> <code>MeshLoader_Result_Success</code> </li>
                </ul>

                <p> The <code>MeshLoader_JobsQueryInfo</code> structure is defined as follows:
                    <a id="MeshLoader_JobsQueryInfo"></a> </p>

<pre lang="c">
typedef struct {
    MeshLoader_StructureType            structureType;
    void                              * pNext;
    MeshLoader_JobsQueryFlags           flags;
    MeshLoader_uint32                   jobCount;
    MeshLoader_QueryJobInfo           * pQueryJobInfos;
} MeshLoader_JobsQueryInfo;
</pre>

                <ul>
                    <li> <code>structureType</code> is the type of the structure. </li>
                    <li> <code>pNext</code> is <code>NULL</code> or a pointer to a structure extending this structure. </li>
                    <li> <code>flags</code> is reserved for future use. </li>
                    <li> <code>jobCount</code> is an unsigned integer specifying the number of Jobs that are to be started. </li>
                    <li> <code>pQueryJobInfos</code> is a pointer to an array of <a href="#MeshLoader_QueryJobInfo">MeshLoader_QueryJobInfo</a> structures,
                        where the query result will be saved. </li>
                </ul>

                <h3>Valid Usage (Implicit)</h3>

                <ul>
                    <li> <small> MLUID-MeshLoader_JobsQueryInfo-structureType </small> <br/>
                        <code>structureType</code> <strong>must</strong> be <code>MeshLoader_StructureType_JobsQueryInfo</code>.
                    </li>
                    <li> <small> MLUID-MeshLoader_JobsQueryInfo-pNext </small> <br/>
                        <code>pNext</code> must be <code>NULL</code>.
                    </li>
                    <li> <small> MLUID-MeshLoader_JobsQueryInfo-flags-parameter </small> <br/>
                        <code>flags</code> <strong>must</strong> be <code>0</code>.
                    </li>
                    <li> <small> MLUID-MeshLoader_JobsQueryInfo-jobCount-parameter </small> <br/>
                        <code>jobCount</code> <strong>must</strong> be greater than <code>0</code>.
                    </li>
                    <li> <small> MLUID-MeshLoader_JobsQueryInfo-pQueryJobInfos-parameter </small> <br/>
                        <code>pQueryJobInfos</code> <strong>must</strong> be a <i>valid</i> pointer to an array of <code>jobCount</code> <i>valid</i> <a href="#MeshLoader_QueryJobInfo">MeshLoader_QueryJobInfo</a> structures.
                    </li>
                </ul>

                <p> The <code>MeshLoader_QueryJobInfo</code> structure is defined as follows:
                    <a id="MeshLoader_QueryJobInfo"></a> </p>

<pre lang="c">
typedef struct {
    MeshLoader_StructureType            structureType;
    void                              * pNext;
    MeshLoader_Job                      job;
    MeshLoader_JobState                 state;
    float                               progress;
} MeshLoader_QueryJobInfo;
</pre>

                <ul>
                    <li> <code>structureType</code> is the type of the structure. </li>
                    <li> <code>pNext</code> is <code>NULL</code> or a pointer to a structure extending this structure. </li>
                    <li> <code>job</code> is a <a href="#MeshLoader_Job">MeshLoader_Job</a> handle, representing the queried job. </li>
                    <li> <code>state</code> will contain a value defined by <a href="#MeshLoader_JobState">MeshLoader_JobState</a> that represents the state of the job, also
                        described in <a href="#jobs-jobLifetimeAndExecution">Job Lifetime & Execution</a> section. </li>
                    <li> <code>progress</code> will contain a floating point value between <code>0.0f</code> and <code>1.0f</code>, representing
                        the job progress the defined range, <code>0.0f</code> representing a job that is not started, and <code>1.0f</code> representing a job
                        that has finished. Another example, a job that is 25% done would have the <code>progress</code> value <code>0.25f</code>.</li>
                </ul>

                <h3>Valid Usage (Implicit)</h3>

                <ul>
                    <li> <small> MLUID-MeshLoader_QueryJobInfo-structureType </small> <br/>
                        <code>structureType</code> <strong>must</strong> be <code>MeshLoader_StructureType_QueryJobInfo</code>.
                    </li>
                    <li> <small> MLUID-MeshLoader_QueryJobInfo-pNext </small> <br/>
                        <code>pNext</code> must be <code>NULL</code>.
                    </li>
                    <li> <small> MLUID-MeshLoader_QueryJobInfo-job-parameter </small> <br/>
                        <code>job</code> <strong>must</strong> contain a <i>valid</i> <a href="#MeshLoader_Job">MeshLoader_Job</a> handle, created in a previous
                        <a href="#MeshLoader_createJobs">MeshLoader_createJobs</a> call.
                    </li>
                </ul>

                <p> The states of a job, as described also in the <a href="#jobs-jobLifetimeAndExecution">Job Lifetime and Execution</a> section, are
                    defined by <code>MeshLoader_JobState</code> enumeration, defined as follows:
                    <a id="MeshLoader_JobState"></a> </p>

<pre lang="c">
typedef enum {
    MeshLoader_JobState_Ready                      = 0x00000001U,
    MeshLoader_JobState_Running                    = 0x00000002U,
    MeshLoader_JobState_Paused                     = 0x00000003U,
    MeshLoader_JobState_Stopped                    = 0x00000004U,
    MeshLoader_JobState_Terminated                 = 0x00000005U,
    MeshLoader_JobState_Finished                   = 0x00000010U,
    MeshLoader_JobState_FinishedError              = 0x00000020U,
} MeshLoader_JobState;
</pre>

                <ul>
                    <li> <code>MeshLoader_JobState_Ready</code> represents the <strong class="strong-state-description">Ready</strong> state of a Job. </li>
                    <li> <code>MeshLoader_JobState_Running</code> represents the <strong class="strong-state-description">Running</strong> state of a Job. </li>
                    <li> <code>MeshLoader_JobState_Paused</code> represents the <strong class="strong-state-description">Paused</strong> state of a Job. </li>
                    <li> <code>MeshLoader_JobState_Stopped</code> represents the <strong class="strong-state-description">Stopped</strong> state of a Job. </li>
                    <li> <code>MeshLoader_JobState_Terminated</code> represents the <strong class="strong-state-description">Terminated</strong> state of a Job. </li>
                    <li> <code>MeshLoader_JobState_Finished</code> represents the <strong class="strong-state-description">Finished</strong> state of a Job. </li>
                    <li> <code>MeshLoader_JobState_FinishedError</code> represents the <strong class="strong-state-description">Finished Error</strong> state of a Job. </li>
                </ul>

                <p> To query whether any jobs are running, call:
                    <a id="MeshLoader_anyJobsRunning"></a> </p>

<pre lang="c">
MeshLoader_Result MeshLoader_anyJobsRunning (
    MeshLoader_Instance                     instance,
    MeshLoader_bool                       * pAnyRunning
);
</pre>
                <ul>
                    <li> <code>instance</code> is a handle of a <i>valid</i> <a href="#MeshLoader_Instance">MeshLoader_Instance</a> handle previously created with <a href="#MeshLoader_createInstance">MeshLoader_createInstance</a>. </li>
                    <li> <code>pAnyRunning</code> is a pointer to a <a href="#bool">MeshLoader_bool</a> value to store the operation result in.
                        If any jobs are running, <code>pAnyRunning</code> will contain <code>MeshLoader_true</code> after the call,
                        <code>MeshLoader_false</code> otherwise. </li>
                </ul>

                <h3> Valid Usage (Implicit) </h3>
                <ul>
                    <li> <small> MLUID-MeshLoader_anyJobsRunning-instance-parameter </small> <br/>
                        <code>instance</code> <strong>must</strong> be a valid <a href="#MeshLoader_Instance">MeshLoader_Instance</a> handle.
                    </li>
                    <li> <small> MLUID-MeshLoader_anyJobsRunning-pAnyRunning-parameter </small> <br/>
                        <code>pAnyRunning</code> <strong>must</strong> be a valid pointer to a <a href="#bool">MeshLoader_bool</a> value.
                    </li>
                </ul>

                <h3> Return Codes </h3>
                <a href="#successCodes">Success</a>
                <ul>
                    <li> <code>MeshLoader_Result_Success</code> </li>
                </ul>
                <a href="#errorCodes">Failure</a>
                <ul>
                    <li> <code>MeshLoader_Result_MutexError</code> </li>
                </ul>

            </div>

            <div>

                <h2 id="jobDestruction">4.5. Job Destruction</h2>

                <p> To destroy a batch of jobs, call:
                    <a id="MeshLoader_destroyJobs"></a> </p>

<pre lang="c">
void MeshLoader_destroyJobs (
    MeshLoader_Instance                     instance,
    MeshLoader_uint32                       jobCount,
    MeshLoader_Job                  const * pJobs,
    MeshLoader_AllocationCallbacks  const * pAllocationCallbacks
);
</pre>

                <ul>
                    <li> <code>instance</code> is a handle of a <i>valid</i> <a href="#MeshLoader_Instance">MeshLoader_Instance</a> handle previously created with <a href="#MeshLoader_createInstance">MeshLoader_createInstance</a>. </li>
                    <li> <code>jobCount</code> is an integer value containing the number of jobs to destroy. </li>
                    <li> <code>pJobs</code> is a pointer to an array of <i>valid</i> <a href="#MeshLoader_Job">MeshLoader_Job</a> handles previously
                        created with <a href="#MeshLoader_createJobs">MeshLoader_createJobs</a>. </li>
                    <li> <code>pAllocationCallbacks</code> controls memory allocation as described in the <a href="#memoryAllocation">Memory Allocation</a> chapter. </li>
                </ul>

                <h3> Valid Usage </h3>
                <ul>
                    <li> <small> MLUID-MeshLoader_destroyJobs-pJobs-00009 </small> <br/>
                        All job objects in the array passed through <code>pJobs</code> <strong>must</strong> be in a
                        <strong class="strong-state-description">Stopped</strong>, <strong class="strong-state-description">Finished</strong>,
                        <strong class="strong-state-description">Finished Error</strong> or <strong class="strong-state-description">Terminated</strong> state.
                    </li>
                    <li> <small> MLUID-MeshLoader_destroyInstance-pJobs-00010 </small> <br/>
                        If <code>MeshLoader_AllocationCallbacks</code> were provided when the jobs contained in the <code>pJobs</code> array of
                        <a href="#MeshLoader_Job">MeshLoader_Job</a> handles were created, a compatible set of
                        callbacks <strong>must</strong> be provided as a parameter for this call.
                    </li>
                    <li> <small> MLUID-MeshLoader_destroyInstance-pJobs-00011 </small> <br/>
                        If no <code>MeshLoader_AllocationCallbacks</code> were provided when the jobs contained in the <code>pJobs</code> array of
                        <a href="#MeshLoader_Job">MeshLoader_Job</a> handles were created, <code>pAllocationCallbacks</code> <strong>must</strong> be <code>NULL</code>.
                    </li>
                </ul>

                <h3> Valid Usage (Implicit) </h3>
                <ul>
                    <li> <small> MLUID-MeshLoader_destroyJobs-instance-parameter </small> <br/>
                        <code>instance</code> <strong>must</strong> be a valid <a href="#MeshLoader_Instance">MeshLoader_Instance</a> handle.
                    </li>
                    <li> <small> MLUID-MeshLoader_destroyJobs-jobCount-parameter </small> <br/>
                        <code>jobCount</code> <strong>must</strong> be greater than <code>0</code>.
                    </li>
                    <li> <small> MLUID-MeshLoader_destroyJobs-pJobs-parameter </small> <br/>
                        <code>jobCount</code> <strong>must</strong> be a <i>valid</i> pointer to an array of <code>jobCount</code> <i>valid</i> <a href="#MeshLoader_Job">MeshLoader_Job</a> handles.
                    </li>
                    <li> <small> MLUID-MeshLoader_createJobs-pAllocationCallbacks-parameter </small> <br/>
                        If <code>pAllocationCallbacks</code> is not <code>NULL</code>, <code>pAllocationCallbacks</code> <strong>must</strong> be a valid pointer
                        to a valid <a href="#MeshLoader_AllocationCallbacks">MeshLoader_AllocationCallbacks</a> structure.
                    </li>
                </ul>

            </div>

        </div>

        <div>

            <h1 id="meshes">5. Meshes</h1>

            <p> The end purpose of the Job Objects described in the previous chapter, and consequently, this library, is
                to load mesh objects. These are representations of 3D models, and come in several formats. These usually
                describe and object using <strong>vertices</strong> and <strong>faces</strong>. While this is the minimum
                required data for a model representation, some formats include additional specialized data, such as
                <strong>normal vectors</strong>, <strong>texture data</strong> or <strong>bump maps</strong>. </p>

            <p> Any data format or specialized data structure that is not available in the implementation can be defined
                through <a href="#userDefinedJobs">User Defined Jobs</a> and the interfaces provided for them. </p>

            <p> A <a href="#MeshLoader_Job">MeshLoader_Job</a> object will create and populate a Mesh object during its lifetime,
                and will make it readable or release it to the main process after it has finished processing. It is up to the
                application whether the Mesh object is only read from the job or taken from it. </p>

            <p> A Mesh Object is represented by <code>MeshLoader_Mesh</code> handles:
                <a id="MeshLoader_Mesh"></a> </p>

<pre lang="c">
MESH_LOADER_DEFINE_HANDLE ( MeshLoader_Mesh )
</pre>

            <div>

                <h2 id="meshes-ownership">5.1. Mesh Ownership</h2>

                <p> Mesh Objects that are only read from Jobs <strong>must</strong> not be destroyed by the application. These
                    will be freed upon the job's destruction or upon its restart. These are referred to as <strong>job-owned</strong>. </p>
                <p> Mesh Objects that are taken from Jobs <strong>must</strong> be destroyed. After a Mesh Object is taken from
                    a job successfully, subsequent attempts to read/take a Mesh Object from that Job will not yield another object,
                    unless the job goes through another load-cycle (restart->finish). These are referred to as <strong>application-owned</strong>. </p>

            </div>

            <div>

                <h2 id="meshes-meshAcquisition">5.2. Mesh Acquisition</h2>

                <p> To acquire a mesh and without releasing it from the job, leaving the implementation to destroy it, call:
                    <a id="MeshLoader_getMesh"></a> </p>

<pre lang="c">
MeshLoader_Result MeshLoader_getMesh (
        MeshLoader_Job                          job,
        MeshLoader_Mesh                       * pMesh
);
</pre>

                <ul>
                    <li> <code>job</code> is a <a href="#MeshLoader_Job">MeshLoader_Job</a> handle previously created with
                        <a href="#MeshLoader_createJobs">MeshLoader_createJobs</a>. </li>
                    <li> <code>pMesh</code> is a pointer to a <a href="#MeshLoader_Mesh">MeshLoader_Mesh</a> handle to store
                        the resulting Mesh Object handle in upon successful completion. </li>
                </ul>

                <h3>Valid Usage</h3>

                <ul>
                    <li> <small>MLUID-MeshLoader_getMesh-job-00016</small> <br/>
                        <code>job</code> <strong>should</strong> represent a Job Object whose state is <strong class="strong-state-description">Finished</strong>,
                        as described in the <a href="#jobs-jobLifetimeAndExecution">Job Lifetime and Execution</a> section. </li>
                    <li> <small>MLUID-MeshLoader_getMesh-job-00017</small> <br/>
                        <code>job</code> <strong>must</strong> not have been given to a <code>MeshLoader_takeMesh</code> call as the <code>job</code>
                        parameter before this call without having gone through another load-cycle(start->finish). </li>
                    <li> <small>MLUID-MeshLoader_getMesh-pMesh-00023</small> <br/>
                        The <a href="#MeshLoader_Mesh">MeshLoader_Mesh</a> handle located at <code>pMesh</code> <strong>must</strong> not be a <i>valid</i>, <a href="#meshes-ownership">application-owned</a> handle.</li>
                </ul>

                <h3>Valid Usage (Implicit)</h3>

                <ul>
                    <li> <small>MLUID-MeshLoader_getMesh-job-parameter</small> <br/>
                        <code>job</code> <strong>must</strong> be a <i>valid</i> <a href="#MeshLoader_Job">MeshLoader_Job</a> handle. </li>
                    <li> <small>MLUID-MeshLoader_getMesh-pMesh-parameter</small> <br/>
                        <code>pMesh</code> <strong>must</strong> be a <i>valid</i> pointer to a <a href="#MeshLoader_Mesh">MeshLoader_Mesh</a> handle. </li>
                </ul>

                <h3>Return Codes</h3>
                <a href="#successCodes">Success</a>
                <ul>
                    <li> <code>MeshLoader_Result_Success</code> </li>
                    <li> <code>MeshLoader_Result_JobNotStarted</code> </li>
                    <li> <code>MeshLoader_Result_NotReady</code> </li>
                </ul>
                <a href="#errorCodes">Failure</a>
                <ul>
                    <li> <code>MeshLoader_Result_JobExecutionFailed</code> </li>
                </ul>

                <p> The mesh obtained in <code>pMesh</code> from a successful call will be a <a href="#meshes-ownership">job-owned</a> mesh. </p>

                <p> To take a mesh by releasing it from the job, requiring the acquired mesh to be destroyed by the application, call:
                    <a id="MeshLoader_takeMesh"></a> </p>

<pre lang="c">
MeshLoader_Result MeshLoader_takeMesh (
        MeshLoader_Job                          job,
        MeshLoader_AllocationCallbacks  const * pAllocationCallbacks,
        MeshLoader_Mesh                       * pMesh
);
</pre>

                <ul>
                    <li> <code>job</code> is a <a href="#MeshLoader_Job">MeshLoader_Job</a> handle previously created with
                        <a href="#MeshLoader_createJobs">MeshLoader_createJobs</a>. </li>
                    <li> <code>pAllocationCallbacks</code> controls memory allocation as described in the <a href="#memoryAllocation">Memory Allocation</a> chapter. </li>
                    <li> <code>pMesh</code> is a pointer to a <a href="#MeshLoader_Mesh">MeshLoader_Mesh</a> handle to store
                        the resulting Mesh Object handle in upon successful completion. </li>
                </ul>

                <h3>Valid Usage</h3>

                <ul>
                    <li> <small>MLUID-MeshLoader_takeMesh-job-00018</small> <br/>
                        <code>job</code> <strong>should</strong> represent a Job Object whose state is <strong class="strong-state-description">Finished</strong>,
                        as described in the <a href="#jobs-jobLifetimeAndExecution">Job Lifetime and Execution</a> section. </li>
                    <li> <small>MLUID-MeshLoader_takeMesh-job-00019</small> <br/>
                        <code>job</code> <strong>must</strong> not have been given to a <code>MeshLoader_takeMesh</code> call as the <code>job</code>
                        parameter before this call without having gone through another load-cycle(start->finish). </li>
                    <li> <small>MLUID-MeshLoader_takeMesh-pAllocationCallbacks-00020</small> <br/>
                        If the <a href="#MeshLoader_JobsStartInfo">MeshLoader_JobsStartInfo</a> passed to the <a href="#MeshLoader_startJobs">MeshLoader_startJobs</a>
                        call that created the <code>job</code> was given a valid, not <code>NULL</code> <a href="#MeshLoader_AllocationCallbacks">MeshLoader_AllocationCallbacks</a>,
                        <code>pAllocationCallbacks</code> given here <strong>should</strong> point to the same structure. The application does take into account the possibility
                        of another structure being given here, which will re-allocate all mesh data with these callbacks, and free them from the one stored at start. </li>
                    <li> <small>MLUID-MeshLoader_takeMesh-pAllocationCallbacks-00021</small> <br/>
                        If the <a href="#MeshLoader_JobsStartInfo">MeshLoader_JobsStartInfo</a> passed to the <a href="#MeshLoader_startJobs">MeshLoader_startJobs</a>
                        call that created the <code>job</code> was <code>NULL</code>,
                        <code>pAllocationCallbacks</code> given here <strong>should</strong> also be <code>NULL</code>. The application does take into account the possibility
                        of these not being <code>NULL</code>, in which case the library will use internal allocations to free the original mesh data, or reallocate the new mesh data,
                        depending on which of the allocator values was <code>NULL</code>. </li>
                    <li> <small>MLUID-MeshLoader_takeMesh-pMesh-00022</small> <br/>
                        The <a href="#MeshLoader_Mesh">MeshLoader_Mesh</a> handle located at <code>pMesh</code> <strong>must</strong> not be a <i>valid</i>, <a href="#meshes-ownership">application-owned</a> handle.</li>
                </ul>

                <h3>Valid Usage (Implicit)</h3>

                <ul>
                    <li> <small>MLUID-MeshLoader_takeMesh-job-parameter</small> <br/>
                        <code>job</code> <strong>must</strong> be a <i>valid</i> <a href="#MeshLoader_Job">MeshLoader_Job</a> handle. </li>
                    <li> <small> MLUID-MeshLoader_createJobs-pAllocationCallbacks-parameter </small> <br/>
                        If <code>pAllocationCallbacks</code> is not <code>NULL</code>, <code>pAllocationCallbacks</code> <strong>must</strong> be a valid pointer
                        to a valid <a href="#MeshLoader_AllocationCallbacks">MeshLoader_AllocationCallbacks</a> structure.
                    </li>
                    <li> <small>MLUID-MeshLoader_takeMesh-pMesh-parameter</small> <br/>
                        <code>pMesh</code> <strong>must</strong> be a <i>valid</i> pointer to a <a href="#MeshLoader_Mesh">MeshLoader_Mesh</a> handle. </li>
                </ul>

                <h3>Return Codes</h3>
                <a href="#successCodes">Success</a>
                <ul>
                    <li> <code>MeshLoader_Result_Success</code> </li>
                    <li> <code>MeshLoader_Result_JobNotStarted</code> </li>
                    <li> <code>MeshLoader_Result_NotReady</code> </li>
                </ul>
                <a href="#errorCodes">Failure</a>
                <ul>
                    <li> <code>MeshLoader_Result_JobExecutionFailed</code> </li>
                </ul>

                <p> The mesh obtained in <code>pMesh</code> from a successful call will be an <a href="#meshes-ownership">application-owned</a> mesh. </p>

            </div>

            <div>

                <h2 id="meshes-readingMeshData">5.3. Reading Mesh Data</h2>

                <p> The mesh contained data can be acquired in a read-only format, in a structure, or by enumeration of individual formats, by copy. </p>
                <p> The data contained in the mesh depends on the <a href="#MeshLoader_MeshLoadModeFlags">MeshLoader_MeshLoadModeFlags</a> specified
                    to the <a href="#MeshLoader_CreateJobInfo">MeshLoader_CreateJobInfo</a> in the <a href="#MeshLoader_JobsCreateInfo">MeshLoader_JobsCreateInfo</a> given
                    to the <a href="#MeshLoader_createJobs">MeshLoader_createJobs</a> call that created the <a href="#MeshLoader_Job">MeshLoader_Job</a> that loaded the Mesh. </p>

                <p> Each flag adds to the behavior, does not block another load behavior unless explicitly specified, and behave as described: </p>
                <ul>
                    <li> If <code>MeshLoader_MeshLoadModeFlag_LoadFaces</code> was used, the Mesh will have <strong>face data</strong> loaded. </li>
                    <li> If <code>MeshLoader_MeshLoadModeFlag_LoadIndices</code> was used, the Mesh will have <strong>face data</strong> loaded, formatted as one array of indices. </li>
                </ul>

                <p> To read the mesh data in a read-only format, call:
                    <a id="MeshLoader_getMeshData"></a> </p>

<pre lang="c">
MeshLoader_Result MeshLoader_getMeshData (
        MeshLoader_Mesh                         mesh,
        MeshLoader_MeshData                   * pMeshData
);
</pre>
                <ul>
                    <li> <code>mesh</code> is a <a href="#MeshLoader_Mesh">MeshLoader_Mesh</a> handle previously read/acquired from a <a href="#MeshLoader_Job">MeshLoader_Job</a>
                        with either the <a href="#MeshLoader_getMesh">MeshLoader_getMesh</a> call or the <a href="#MeshLoader_takeMesh">MeshLoader_takeMesh</a> call. </li>
                    <li> <code>pMeshData</code> is a pointer to a <a href="#MeshLoader_MeshData">MeshLoader_MeshData</a> structure, where the read-only mesh-data will be
                        stored after a successful call. </li>
                </ul>

                <h3>Valid Usage (Implicit)</h3>

                <ul>
                    <li> <small>MLUID-MeshLoader_getMeshData-mesh-parameter</small> <br/>
                        <code>mesh</code> <strong>must</strong> be a <i>valid</i> <a href="#MeshLoader_Mesh">MeshLoader_Mesh</a> handle. </li>
                    <li> <small> MLUID-MeshLoader_getMeshData-pMeshData-parameter </small> <br/>
                        <code>pMeshData</code> <strong>must</strong> be a <i>valid</i> pointer to a <i>valid</i> <a href="#MeshLoader_MeshData">MeshLoader_MeshData</a> structure.
                    </li>
                </ul>

                <h3>Return Codes</h3>
                <a href="#successCodes">Success</a>
                <ul>
                    <li> <code>MeshLoader_Result_Success</code> </li>
                </ul>

                <p> The <code>MeshLoader_MeshData</code> structure is defined as follows:
                    <a id="MeshLoader_MeshData"></a> </p>

<pre lang="c">
typedef struct {
    MeshLoader_StructureType        structureType;
    void                          * pNext;
    MeshLoader_uint32               vertexCount;
    MeshLoader_VertexData   const * pVertices;
    MeshLoader_uint32               faceCount;
    MeshLoader_FaceData     const * pFaces;
    MeshLoader_IndexData    const * pIndexData;
} MeshLoader_MeshData;
</pre>
                <ul>
                    <li> <code>structureType</code> is the type of the structure. </li>
                    <li> <code>pNext</code> is <code>NULL</code> or a pointer to a structure extending this structure. </li>
                    <li> <code>vertexCount</code> is an unsigned integer representing the number of vertices the mesh is composed of. </li>
                    <li> <code>pVertices</code> is a pointer to an array of <a href="#MeshLoader_VertexData">MeshLoader_VertexData</a> structures, representing the
                        vertices the mesh is composed of. </li>
                    <li> <code>faceCount</code> is an unsigned integer representing the number of faces the mesh is composed of. </li>
                    <li> <code>pFaces</code> is a pointer to an array of <a href="#MeshLoader_FaceData">MeshLoader_FaceData</a> structures, representing the
                        faces the mesh is composed of. </li>
                </ul>

                <p> After a successful call of <code>MeshLoader_getMeshData</code>, the <a href="#MeshLoader_MeshData"></a> at <code>pMesh</code>
                    will contain the following: </p>

                <ul>
                    <li> <code>vertexCount</code> will be set to the number of vertices the mesh is composed of. </li>
                    <li> <code>pVertices</code> will be a pointer to an array of <code>vertexCount</code> <i>valid</i>
                        <a href="#MeshLoader_VertexData">MeshLoader_VertexData</a> structures. </li>
                    <li> If <code>MeshLoader_MeshLoadModeFlag_LoadFaces</code> was used, <code>faceCount</code> will be set to the
                        number of faces the mesh is composed of. </li>
                    <li> If <code>MeshLoader_MeshLoadModeFlag_LoadFaces</code> was used, <code>pFaces</code> will be a pointer to an
                        array of <code>faceCount</code> <i>valid</i> <a href="#MeshLoader_FaceData">MeshLoader_FaceData</a> structures. </li>
                    <li> If <code>MeshLoader_MeshLoadModeFlag_LoadFaces</code> was not used, <code>faceCount</code> will be <code>0</code>. </li>
                    <li> If <code>MeshLoader_MeshLoadModeFlag_LoadFaces</code> was not used, <code>pFaces</code> will be <code>NULL</code>. </li>
                    <li> If <code>MeshLoader_MeshLoadModeFlag_LoadIndices</code> was used, <code>pIndexData</code> will be a pointer to a
                        <i>valid</i> <a href="#MeshLoader_IndexData">MeshLoader_IndexData</a> structure. </li>
                    <li> If <code>MeshLoader_MeshLoadModeFlag_LoadIndices</code> was not used, <code>pIndexData</code> will be <code>NULL</code>.
                </ul>

                <h3>Valid Usage (Implicit)</h3>
                <ul>
                    <li> <small>MLUID-MeshLoader_MeshData-structureType</small> <br/>
                        <code>structureType</code> <strong>must</strong> be <code>MeshLoader_StructureType_MeshData</code>. </li>
                    <li> <small>MLUID-MeshLoader_MeshData-pNext</small> <br/>
                        <code>pNext</code> <strong>must</strong> be <code>NULL</code>. </li>
                </ul>

                <p> The <code>MeshLoader_VertexData</code> structure is described as follows:
                    <a id="MeshLoader_VertexData"></a> </p>

<pre lang="c">
typedef struct {
    double x;
    double y;
    double z;
} MeshLoader_VertexData;
</pre>
                <ul>
                    <li> <code>x</code> represents the first coordinate of the vertex, used to represent it in 3D space. </li>
                    <li> <code>y</code> represents the second coordinate of the vertex, used to represent it in 3D space. </li>
                    <li> <code>z</code> represents the third coordinate of the vertex, used to represent it in 3D space. </li>
                </ul>

                <p> The <code>MeshLoader_FaceData</code> structure is described as follows:
                    <a id="MeshLoader_FaceData"></a> </p>

<pre lang="c">
typedef struct {
    MeshLoader_uint32 u;
    MeshLoader_uint32 v;
    MeshLoader_uint32 w;
} MeshLoader_FaceData;
</pre>
                <ul>
                    <li> <code>u</code> represents the first index of the face, to start drawing from. </li>
                    <li> <code>v</code> represents the second index of the face, to start drawing from. </li>
                    <li> <code>w</code> represents the third index of the face, to start drawing from. </li>
                </ul>

                <p> The <code>MeshLoader_IndexData</code> structure is described as follows:
                    <a id="MeshLoader_IndexData"></a> </p>

<pre lang="c">
typedef struct {
    MeshLoader_uint32           indexCount;
    MeshLoader_uint32   const * pIndices;
} MeshLoader_IndexData;
</pre>
                <ul>
                    <li> <code>indexCount</code> is the number of vertex drawing indices in the mesh. </li>
                    <li> <code>pIndices</code> is a pointer to an array of vertex drawing indices. </li>
                </ul>

                <p> After a successful call of <code>MeshLoader_getMeshData</code> with <code>MeshLoader_MeshLoadModeFlag_LoadIndices</code>,
                    the <a href="#MeshLoader_MeshData"></a>'s <code>pIndexData</code>
                    will contain the following: </p>

                <ul>
                    <li> <code>indexCount</code> will be the number of vertex drawing indices, equivalent to 3 * faceCount. </li>
                    <li> <code>pIndices</code> will be a <i>valid</i> pointer to an array of <code>indexCount</code> indices. </li>
                </ul>

                <p> To enumerate the vertices of a mesh, call:
                    <a id="MeshLoader_enumerateMeshVertices"></a> </p>

<pre lang="c">
MeshLoader_Result MeshLoader_enumerateMeshVertices (
        MeshLoader_Mesh                         mesh,
        MeshLoader_uint32                     * pVertexCount,
        MeshLoader_VertexData                 * pVertices
);
</pre>
                <ul>
                    <li> <code>mesh</code> is a <a href="#MeshLoader_Mesh">MeshLoader_Mesh</a> handle previously read/acquired from a
                        <a href="#MeshLoader_Job">MeshLoader_Job</a> with either the <a href="#MeshLoader_getMesh">MeshLoader_getMesh</a> call or
                        the <a href="#MeshLoader_takeMesh">MeshLoader_takeMesh</a> call. </li>
                    <li> <code>pVertexCount</code> is a pointer to an unsigned integer related to the number of vertices queried, as described below. </li>
                    <li> <code>pVertices</code> is either <code>NULL</code> or a pointer to an array of <a href="#MeshLoader_VertexData">MeshLoader_VertexData</a> structures. </li>
                </ul>

                <p> If <code>pVertices</code> is <code>NULL</code>, then the number of vertices available is returned in <code>pVertexCount</code>.
                    Otherwise, <code>pVertexCount</code> <strong>must</strong> point to a variable set by the user to the number of elements in the
                    <code>pVertices</code> array, and on return the variable is overwritten with the number of structures actually written to
                    <code>pVertices</code>. If <code>pVertexCount</code> is less than the number of vertices, at most <code>pVertexCount</code>
                    structures will be written, and <code>MeshLoader_Result_TooSmall</code> will be returned instead of
                    <code>MeshLoader_Result_Success</code>, to indicate that not all the available vertices were returned. </p>

                <h3>Valid Usage (Implicit)</h3>
                <ul>
                    <li> <small>MLUID-MeshLoader_enumerateMeshVertices-mesh-parameter</small> <br/>
                        <code>mesh</code> <strong>must</strong> be a <i>valid</i> <a href="#MeshLoader_Mesh">MeshLoader_Mesh</a> handle.</li>
                    <li> <small>MLUID-MeshLoader_enumerateMeshVertices-mesh-pVertexCount</small> <br/>
                        <code>pVertexCount</code> <strong>must</strong> be a <i>valid</i> pointer to a <a href="#int">MeshLoader_uint32</a> value. </li>
                    <li> <small>MLUID-MeshLoader_enumerateMeshVertices-mesh-pVertices</small> <br/>
                        If the value referenced by <code>pVertexCount</code> is not <code>0</code>, and <code>pVertices</code> is not <code>NULL</code>,
                        <code>pVertices</code> <strong>must</strong> be a <i>valid</i> pointer to an array of <code>pVertexCount</code> <i>valid</i>
                        <a href="#MeshLoader_VertexData">MeshLoader_VertexData</a> structures. </li>
                </ul>

                <h3>Return Codes</h3>
                <a href="#successCodes">Success</a>
                <ul>
                    <li> <code>MeshLoader_Result_Success</code> </li>
                    <li> <code>MeshLoader_Result_TooSmall</code> </li>
                </ul>
                <a href="#errorCodes">Failure</a>
                <ul>
                    <li> <code>MeshLoader_Result_ResourceNotFound</code> </li>
                </ul>

                <p> If loaded with <code>MeshLoader_MeshLoadModeFlag_LoadFaces</code>, the faces of a mesh can be enumerated by calling:
                    <a id="MeshLoader_enumerateMeshFaces"></a> </p>

<pre lang="c">
MeshLoader_Result MeshLoader_enumerateMeshFaces (
        MeshLoader_Mesh                         mesh,
        MeshLoader_uint32                     * pFaceCount,
        MeshLoader_FaceData                   * pFaces
);
</pre>
                <ul>
                    <li> <code>mesh</code> is a <a href="#MeshLoader_Mesh">MeshLoader_Mesh</a> handle previously read/acquired from a
                        <a href="#MeshLoader_Job">MeshLoader_Job</a> with either the <a href="#MeshLoader_getMesh">MeshLoader_getMesh</a> call or
                        the <a href="#MeshLoader_takeMesh">MeshLoader_takeMesh</a> call. </li>
                    <li> <code>pFaceCount</code> is a pointer to an unsigned integer related to the number of faces queried, as described below. </li>
                    <li> <code>pFaces</code> is either <code>NULL</code> or a pointer to an array of <a href="#MeshLoader_FaceData">MeshLoader_FaceData</a> structures. </li>
                </ul>

                <p> If <code>pFaces</code> is <code>NULL</code>, then the number of faces available is returned in <code>pFaceCount</code>.
                    Otherwise, <code>pFaceCount</code> <strong>must</strong> point to a variable set by the user to the number of elements in the
                    <code>pFaces</code> array, and on return the variable is overwritten with the number of structures actually written to
                    <code>pFaces</code>. If <code>pFaceCount</code> is less than the number of faces, at most <code>pFaceCount</code>
                    structures will be written, and <code>MeshLoader_Result_TooSmall</code> will be returned instead of
                    <code>MeshLoader_Result_Success</code>, to indicate that not all the available faces were returned. </p>

                <h3>Valid Usage</h3>
                <ul>
                    <li> <small>MLUID-MeshLoader_enumerateMeshFaces-loadMode-00027</small> <br/>
                        <code>mesh</code> <strong>must</strong> be a <a href="#MeshLoader_Mesh">MeshLoader_Mesh</a> handle obtained from a job that
                        was created and loaded with <code>MeshLoader_MeshLoadModeFlag_LoadFaces</code>. </li>
                </ul>

                <h3>Valid Usage (Implicit)</h3>
                <ul>
                    <li> <small>MLUID-MeshLoader_enumerateMeshFaces-mesh-parameter</small> <br/>
                        <code>mesh</code> <strong>must</strong> be a <i>valid</i> <a href="#MeshLoader_Mesh">MeshLoader_Mesh</a> handle.</li>
                    <li> <small>MLUID-MeshLoader_enumerateMeshFaces-mesh-pFaceCount</small> <br/>
                        <code>pFaceCount</code> <strong>must</strong> be a <i>valid</i> pointer to a <a href="#int">MeshLoader_uint32</a> value. </li>
                    <li> <small>MLUID-MeshLoader_enumerateMeshFaces-mesh-pFaces</small> <br/>
                        If the value referenced by <code>pFaceCount</code> is not <code>0</code>, and <code>pFaces</code> is not <code>NULL</code>,
                        <code>pFaces</code> <strong>must</strong> be a <i>valid</i> pointer to an array of <code>pFaceCount</code> <i>valid</i>
                        <a href="#MeshLoader_FaceData">MeshLoader_FaceData</a> structures. </li>
                </ul>

                <h3>Return Codes</h3>
                <a href="#successCodes">Success</a>
                <ul>
                    <li> <code>MeshLoader_Result_Success</code> </li>
                    <li> <code>MeshLoader_Result_TooSmall</code> </li>
                </ul>
                <a href="#errorCodes">Failure</a>
                <ul>
                    <li> <code>MeshLoader_Result_ResourceNotFound</code> </li>
                </ul>

                <p> If loaded with <code>MeshLoader_MeshLoadModeFlag_LoadIndices</code>, the faces of a mesh can be enumerated by calling:
                    <a id="MeshLoader_enumerateIndices"></a> </p>

<pre lang="c">
MeshLoader_Result MeshLoader_enumerateIndices (
        MeshLoader_Mesh                         mesh,
        MeshLoader_uint32                     * pIndexCount,
        MeshLoader_uint32                     * pIndices
);
</pre>
                <ul>
                    <li> <code>mesh</code> is a <a href="#MeshLoader_Mesh">MeshLoader_Mesh</a> handle previously read/acquired from a
                        <a href="#MeshLoader_Job">MeshLoader_Job</a> with either the <a href="#MeshLoader_getMesh">MeshLoader_getMesh</a> call or
                        the <a href="#MeshLoader_takeMesh">MeshLoader_takeMesh</a> call. </li>
                    <li> <code>pIndexCount</code> is a pointer to an unsigned integer related to the number of index queried, as described below. </li>
                    <li> <code>pIndices</code> is either <code>NULL</code> or a pointer to an array of <a href="#int">MeshLoader_uint32</a> values. </li>
                </ul>

                <p> If <code>pIndices</code> is <code>NULL</code>, then the number of indices available is returned in <code>pIndexCount</code>.
                    Otherwise, <code>pIndexCount</code> <strong>must</strong> point to a variable set by the user to the number of elements in the
                    <code>pIndices</code> array, and on return the variable is overwritten with the number of values actually written to
                    <code>pIndices</code>. If <code>pIndexCount</code> is less than the number of indices, at most <code>pIndices</code>
                    values will be written, and <code>MeshLoader_Result_TooSmall</code> will be returned instead of
                    <code>MeshLoader_Result_Success</code>, to indicate that not all the available indices were returned. </p>

                <h3>Valid Usage</h3>
                <ul>
                    <li> <small>MLUID-MeshLoader_enumerateIndices-loadMode-00028</small> <br/>
                        <code>mesh</code> <strong>must</strong> be a <a href="#MeshLoader_Mesh">MeshLoader_Mesh</a> handle obtained from a job that
                        was created and loaded with <code>MeshLoader_MeshLoadModeFlag_LoadIndices</code>. </li>
                </ul>

                <h3>Valid Usage (Implicit)</h3>
                <ul>
                    <li> <small>MLUID-MeshLoader_enumerateIndices-mesh-parameter</small> <br/>
                        <code>mesh</code> <strong>must</strong> be a <i>valid</i> <a href="#MeshLoader_Mesh">MeshLoader_Mesh</a> handle.</li>
                    <li> <small>MLUID-MeshLoader_enumerateIndices-mesh-pIndexCount</small> <br/>
                        <code>pIndexCount</code> <strong>must</strong> be a <i>valid</i> pointer to a <a href="#int">MeshLoader_uint32</a> value. </li>
                    <li> <small>MLUID-MeshLoader_enumerateIndices-mesh-pIndices</small> <br/>
                        If the value referenced by <code>pIndexCount</code> is not <code>0</code>, and <code>pIndices</code> is not <code>NULL</code>,
                        <code>pIndices</code> <strong>must</strong> be a <i>valid</i> pointer to an array of <code>pIndexCount</code> <i>valid</i>
                        <a href="#int">MeshLoader_uint32</a> values. </li>
                </ul>

                <h3>Return Codes</h3>
                <a href="#successCodes">Success</a>
                <ul>
                    <li> <code>MeshLoader_Result_Success</code> </li>
                    <li> <code>MeshLoader_Result_TooSmall</code> </li>
                </ul>
                <a href="#errorCodes">Failure</a>
                <ul>
                    <li> <code>MeshLoader_Result_ResourceNotFound</code> </li>
                </ul>

            </div>

            <div>

                <h2 id="meshes-meshDestruction">5.4. Mesh Destruction</h2>

                <p> To destroy an <a href="#meshes-ownership">application-owned</a> mesh, call:
                    <a id="MeshLoader_destroyMesh"></a> </p>

<pre lang="c">
void MeshLoader_destroyMesh (
        MeshLoader_Mesh                         mesh,
        MeshLoader_AllocationCallbacks  const * pAllocationCallbacks
);
</pre>

                <ul>
                    <li> <code>mesh</code> is a <a href="#MeshLoader_Mesh">MeshLoader_Mesh</a> handle previously acquired from a <a href="#MeshLoader_Job">MeshLoader_Job</a>
                        with a <a href="#MeshLoader_takeMesh">MeshLoader_takeMesh</a> call. </li>
                    <li> <code>pAllocationCallbacks</code> controls memory allocation as described in the <a href="#memoryAllocation">Memory Allocation</a> chapter. </li>
                </ul>

                <h3>Valid Usage</h3>

                <ul>
                    <li> <small>MLUID-MeshLoader_destroyMesh-mesh-00024</small> <br/>
                        The <code>mesh</code> handle <strong>must</strong> be an <a href="#meshes-ownership">application-owned</a> handle.</li>
                    <li> <small>MLUID-MeshLoader_destroyMesh-pAllocationCallbacks-00025</small> <br/>
                        If <code>MeshLoader_AllocationCallbacks</code> were provided when the <code>mesh</code> was acquired using <code>MeshLoader_takeMesh</code>, a compatible
                        set of callbacks <strong>must</strong> be provided as a parameter for this call. </li>
                    <li> <small>MLUID-MeshLoader_destroyMesh-pAllocationCallbacks-00026</small> <br/>
                        If no <code>MeshLoader_AllocationCallbacks</code> were provided when the <code>mesh</code> was acquired using <code>MeshLoader_takeMesh</code>,
                        <code>pAllocationCallbacks</code> <strong>must</strong> be <code>NULL</code>. </li>
                </ul>

                <h3>Valid Usage (Implicit)</h3>

                <ul>
                    <li> <small>MLUID-MeshLoader_destroyMesh-mesh-parameter</small> <br/>
                        <code>mesh</code> <strong>must</strong> be a <i>valid</i> <a href="#MeshLoader_Mesh">MeshLoader_Mesh</a> handle. </li>
                    <li> <small> MLUID-MeshLoader_destroyMesh-pAllocationCallbacks-parameter </small> <br/>
                        If <code>pAllocationCallbacks</code> is not <code>NULL</code>, <code>pAllocationCallbacks</code> <strong>must</strong> be a valid pointer
                        to a valid <a href="#MeshLoader_AllocationCallbacks">MeshLoader_AllocationCallbacks</a> structure.
                    </li>
                </ul>

            </div>

        </div>

        <div>

            <h1 id="memoryAllocation">6. Memory Allocation</h1>

            <p> The Mesh Loader Library provides applications the opportunity to perform memory allocations on behalf of the library implementations.
                If this feature is not used, the implementation will perform its own memory allocations. Since most memory allocations are off the critical path,
                this is not meant as a performance feature. Rather, this <strong>can</strong> be useful for certain embedded systems, for systems with existing
                dedicated allocation, for debugging purposes (e.g. putting a guard page after all allocations), or for memory allocation logging.
            </p>

            <p> Memory Allocation Handing is done via providing allocator functions in a <code>MeshLoader_AllocationCallbacks</code> structure, defined as:
                <a id="MeshLoader_AllocationCallbacks"></a> </p>

<pre lang="c">
typedef struct {
    MeshLoader_StructureType                            structureType;
    void                                              * pNext;
    void                                              * pUserData;
    MeshLoader_AllocationFunction                       allocationFunction;
    MeshLoader_ReallocationFunction                     reallocationFunction;
    MeshLoader_FreeFunction                             freeFunction;
    MeshLoader_InternalAllocationNotificationFunction   internalAllocationNotificationFunction;
    MeshLoader_InternalAllocationNotificationFunction   internalReallocationNotificationFunction;
    MeshLoader_InternalAllocationNotificationFunction   internalFreeNotificationFunction;
} MeshLoader_AllocationCallbacks;
</pre>

            <ul>
                <li> <code>structureType</code> is the type of the structure. </li>
                <li> <code>pNext</code> is <code>NULL</code> or a pointer to a structure extending this structure. </li>
                <li> <code>pUserData</code> is a value to be interpreted by the implementation of the callbacks. When any of the callbacks in
                    <code>MeshLoader_AllocationCallbacks</code> are called, the library implementation will pass this value as the first parameter
                    to the callback. This value <strong>can</strong> vary each time the allocator is passed into a command, even when
                    the same object takes an allocator in multiple commands. </li>
                <li> <code>allocationFunction</code> is a <a href="#MeshLoader_AllocationFunction">MeshLoader_AllocationFunction</a>
                    pointer to an application-defined memory allocation function. </li>
                <li> <code>reallocationFunction</code> is a <a href="#MeshLoader_ReallocationFunction">MeshLoader_ReallocationFunction</a>
                    pointer to an application-defined memory reallocation function. </li>
                <li> <code>freeFunction</code> is a <a href="#MeshLoader_FreeFunction">MeshLoader_FreeFunction</a>
                    pointer to an application-defined memory free function. </li>
                <li> <code>internalAllocationNotificationFunction</code> is a <a href="#MeshLoader_InternalAllocationNotificationFunction">MeshLoader_InternalAllocationNotificationFunction</a>
                    pointer to an application-defined function that is called by the implementation when the library makes internal allocations. </li>
                <li> <code>internalReallocationNotificationFunction</code> is a <a href="#MeshLoader_InternalAllocationNotificationFunction">MeshLoader_InternalAllocationNotificationFunction</a>
                    pointer to an application-defined function that is called by the implementation when the library makes internal reallocations. </li>
                <li> <code>internalFreeNotificationFunction</code> is a <a href="#MeshLoader_InternalAllocationNotificationFunction">MeshLoader_InternalAllocationNotificationFunction</a>
                    pointer to an application-defined function that is called by the implementation when the library frees internal allocations. </li>
            </ul>

            <h3>Valid Usage</h3>

            <ul>
                <li> <small>MLUID-MeshLoader_AllocationCallbacks-allocationFunction-00012</small> <br/>
                    <code>allocationFunction</code> <strong>must</strong> be a <i>valid</i> pointer to a <i>valid</i> user-defined <a href="#MeshLoader_AllocationFunction">MeshLoader_AllocationFunction</a>.
                </li>
                <li> <small>MLUID-MeshLoader_AllocationCallbacks-reallocationFunction-00013</small> <br/>
                    <code>reallocationFunction</code> <strong>must</strong> be a <i>valid</i> pointer to a <i>valid</i> user-defined <a href="#MeshLoader_ReallocationFunction">MeshLoader_ReallocationFunction</a>.
                </li>
                <li> <small>MLUID-MeshLoader_AllocationCallbacks-freeFunction-00014</small> <br/>
                    <code>freeFunction</code> <strong>must</strong> be a <i>valid</i> pointer to a <i>valid</i> user-defined <a href="#MeshLoader_FreeFunction">MeshLoader_FreeFunction</a>.
                </li>
                <li> <small>MLUID-MeshLoader_AllocationCallbacks-internalNotifications-00015</small> <br/>
                    If either of <code>internalAllocationNotificationFunction</code>, <code>internalReallocationNotificationFunction</code> or <code>internalFreeNotificationFunction</code>
                    is not <code>NULL</code>, all three <strong>must</strong> be <i>valid</i> pointers to <i>valid</i> <a href="#MeshLoader_InternalAllocationNotificationFunction">MeshLoader_InternalAllocationNotificationFunction</a>
                    user-defined functions.
                </li>
            </ul>

            <h3>Valid Usage (Implicit)</h3>

            <ul>
                <li> <small>MLUID-MeshLoader_AllocationCallbacks-structureType</small> <br/>
                    <code>structureType</code> <strong>must</strong> be <code>MeshLoader_StructureType_AllocationCallbacks</code>. </li>
                <li> <small>MLUID-MeshLoader_AllocationCallbacks-pNext</small> <br/>
                    <code>pNext</code> <strong>must</strong> be <code>NULL</code>. </li>
            </ul>

            <p> The type of <code>allocationFunction</code>, <code>MeshLoader_AllocationFunction</code> is:
                <a id="MeshLoader_AllocationFunction"></a> </p>

<pre lang="c">
typedef void * ( * MeshLoader_AllocationFunction ) (
    void                              * pUserData,
    MeshLoader_size                     size,
    MeshLoader_size                     alignment,
    MeshLoader_SystemAllocationScope    allocationScope
);
</pre>

            <ul>
                <li> <code>pUserData</code> is the value specified for <a href="#MeshLoader_AllocationCallbacks">MeshLoader_AllocationCallbacks</a><code>::pUserData</code>
                    in the allocator specified by the application. </li>
                <li> <code>size</code> is the size in bytes of the requested allocation. </li>
                <li> <code>alignment</code> is the requested alignment of the allocation in bytes and <strong>must</strong> be a power of two. </li>
                <li> <code>allocationScope</code> is a <a href="#MeshLoader_SystemAllocationScope">MeshLoader_SystemAllocationScope</a> value specifying the
                    allocation scope of the lifetime of the allocation. </li>
            </ul>

            <p> If <code>allocationFunction</code> is unable to allocate the requested memory, it <strong>must</strong> return <code>NULL</code>.
                If the allocation is successful, it <strong>must</strong> return a <i>valid</i> pointer to memory allocation containing at least <code>size</code>
                bytes, and with the pointer value being a multiple of <code>alignment</code> bytes.</p>

            <div class="note">
                <p> Correct library operation <strong>cannot</strong> be assumed if the application does not follow these rules. </p>
                <p> For example, <code>internalAllocation</code> (or <code>internalReallocation</code>) could cause termination of running Mesh Loader instance(s)
                    on a failed allocation for debugging purposes, either directly or indirectly. In these circumstances, it <strong>cannot</strong> be assumed that
                    any part of any affected <a href="#MeshLoader_Instance">MeshLoader_Instance</a> objects are going to operate correctly (even <a href="#MeshLoader_destroyInstance">MeshLoader_destroyInstance</a>)
                    , and the application <strong>must</strong> ensure it cleans up properly via other means (e.g. process termination).</p>
            </div>

            <p> If <code>allocationFunction</code> returns <code>NULL</code>, and the implementation is unable to continue correct processing of the current command
                without the requested allocation, it <strong>must</strong> treat this as a runtime error, and generate <code>MeshLoader_Result_OutOfMemory</code> at
                the appropriate time of the command in which the condition was detected, as described in <a href="#fundamentals-returnCodes">Return Codes</a>. </p>

            <p> If the implementation is able to continue correct processing of the current command without the requested allocation, then it <strong>may</strong> do so,
                and <strong>must</strong> not generate <code>MeshLoader_Result_OutOfMemory</code> as a result of this failed allocation. </p>

            <p> The type of <code>reallocationFunction</code>, <code>MeshLoader_ReallocationFunction</code> is:
                <a id="MeshLoader_ReallocationFunction"></a> </p>

<pre lang="c">
typedef void * ( * MeshLoader_ReallocationFunction ) (
        void                              * pUserData,
        void                              * pOriginal,
        MeshLoader_size                     size,
        MeshLoader_size                     alignment,
        MeshLoader_SystemAllocationScope    allocationScope
);
</pre>

            <ul>
                <li> <code>pUserData</code> is the value specified for <a href="#MeshLoader_AllocationCallbacks">MeshLoader_AllocationCallbacks</a><code>::pUserData</code>
                    in the allocator specified by the application. </li>
                <li> <code>pOriginal</code> <strong>must</strong> be either <code>NULL</code> or a pointer previously returned by <code>allocationFunction</code> or
                    <code>reallocationFunction</code> of a compatible allocator. </li>
                <li> <code>size</code> is the size in bytes of the requested allocation. </li>
                <li> <code>alignment</code> is the requested alignment of the allocation in bytes and <strong>must</strong> be a power of two. </li>
                <li> <code>allocationScope</code> is a <a href="#MeshLoader_SystemAllocationScope">MeshLoader_SystemAllocationScope</a> value specifying the
                    allocation scope of the lifetime of the allocation. </li>
            </ul>

            <p> <code>reallocationFunction</code> <strong>must</strong> return an allocation with enough space for <code>size</code> bytes, and the contents of
                the original allocation from bytes zero to min(original size, new size) - 1 <strong>must</strong> be preserved in the returned allocation. If
                size is larger than the old size, the contents of the additional space are undefined. If satisfying these requirements involves creating a new
                allocation, then the old allocation <strong>should</strong> be freed. </p>

            <p> If <code>pOriginal</code> is <code>NULL</code>, then <code>reallocationFunction</code> <strong>must</strong> behave equivalently to a call of
                <a href="#MeshLoader_AllocationFunction">MeshLoader_AllocationFunction</a> with the same parameter values (without <code>pOriginal</code>) </p>

            <p> If <code>size</code> is zero, then <code>reallocationFunction</code> <strong>must</strong> behave equivalently to a call of
                <a href="#MeshLoader_FreeFunction">MeshLoader_FreeFunction</a> with the same <code>pUserData</code> parameter value, and <code>pMemory</code> equal
                to <code>pOriginal</code>. </p>

            <p> If <code>pOriginal</code> is not <code>NULL</code>, the implementation <strong>must</strong> ensure that <code>alignment</code> is equal to the
                <code>alignment</code> used to originally allocate <code>pOriginal</code>. </p>

            <p> If this function fails and <code>pOriginal</code> is not <code>NULL</code>, the application <strong>must</strong> not free the old allocation. </p>

            <p> Additionally, <code>reallocationFunction</code> <strong>must</strong> follow the same rules for <a href="#MeshLoader_AllocationFunction">MeshLoader_AllocationFunction</a>. </p>

            <p> The type of <code>freeFunction</code>, <code>MeshLoader_FreeFunction</code> is:
                <a id="MeshLoader_FreeFunction"></a> </p>

<pre lang="c">
typedef void ( * MeshLoader_FreeFunction ) (
        void                              * pUserData,
        void                              * pMemory
);
</pre>

            <ul>
                <li> <code>pUserData</code> is the value specified for <a href="#MeshLoader_AllocationCallbacks">MeshLoader_AllocationCallbacks</a><code>::pUserData</code>
                    in the allocator specified by the application. </li>
                <li> <code>pMemory</code> is the allocation to be freed. </li>
            </ul>

            <p> <code>pMemory</code> <strong>may</strong> be <code>NULL</code>, which the callback <strong>must</strong> handle safely. If <code>pMemory</code>
                is not <code>NULL</code>, it <strong>must</strong> be a pointer previously allocated by <code>allocationFunction</code> or
                <code>reallocationFunction</code>. The application <strong>should</strong> free this memory. </p>

            <p> The type of <code>internalAllocationNotificationFunction</code>, <code>internalReallocationNotificationFunction</code> and
                <code>internalFreeNotificationFunction</code> is:
                <a id="MeshLoader_InternalAllocationNotificationFunction"></a> </p>

<pre lang="c">
typedef void ( * MeshLoader_InternalAllocationNotificationFunction ) (
        void                                      * pUserData,
        MeshLoader_AllocationNotification   const * pNotification
);
</pre>

            <ul>
                <li> <code>pUserData</code> is the value specified for <a href="#MeshLoader_AllocationCallbacks">MeshLoader_AllocationCallbacks</a><code>::pUserData</code>
                    in the allocator specified by the application. </li>
                <li> <code>pNotification</code> is a pointer to a <a href="#MeshLoader_AllocationNotification">MeshLoader_AllocationNotification</a> structure,
                    containing the data of the notification. </li>
            </ul>

            <p> These are purely informational callbacks. </p>

            <p> Each allocation has an <i>allocation scope</i> defining its lifetime and which object it is associated with. Possible values passed to the
                <code>allocationScope</code> parameter of the callback functions specified by <a href="#MeshLoader_AllocationCallbacks">MeshLoader_AllocationCallbacks</a>,
                indicating the allocation scope, are:
                <a id="MeshLoader_SystemAllocationScope"></a> </p>

<pre lang="c">
typedef enum {
    MeshLoader_SystemAllocationScope_Unknown        = 0x00000000U,
    MeshLoader_SystemAllocationScope_Instance       = 0x00000001U,
    MeshLoader_SystemAllocationScope_Worker         = 0x00000002U,
    MeshLoader_SystemAllocationScope_Object         = 0x00000003U,
    MeshLoader_SystemAllocationScope_Component      = 0x00000004U,
} MeshLoader_SystemAllocationScope;
</pre>

            <ul>
                <li> <code>MeshLoader_SystemAllocationScope_Unknown</code> specifies that the allocation scope is undefined. </li>
                <li> <code>MeshLoader_SystemAllocationScope_Instance</code> specifies that the allocation is scoped to the lifetime of
                    a <a href="#MeshLoader_Instance">MeshLoader_Instance</a>. </li>
                <li> <code>MeshLoader_SystemAllocationScope_Worker</code> specifies that the allocation is scoped to the lifetime of
                    a <a href="#MeshLoader_Job">MeshLoader_Job</a> being processed by Mesh Loader Workers. This memory <strong>must</strong> be
                    usable across multiple processor threads. </li>
                <li> <code>MeshLoader_SystemAllocationScope_Object</code> specifies that the allocation is scoped to the lifetime of
                    a Mesh Loader Object that is being created or used. </li>
                <li> <code>MeshLoader_SystemAllocationScope_Component</code> specifies that the allocation is scoped to the lifetime of
                    a component of a Mesh Loader Object that is being created or used. </li>
            </ul>

            <p> The <code>MeshLoader_AllocationNotification</code> structure is defined as:
                <a id="MeshLoader_AllocationNotification"></a> </p>

<pre lang="c">
typedef struct {
    MeshLoader_StructureType            structureType;
    void                        const * pNext;
    void                              * pMemory;
    void                              * pOldMemory;
    MeshLoader_size                     size;
    MeshLoader_size                     alignment;
    MeshLoader_SystemAllocationScope    allocationScope;
    MeshLoader_StringLiteral            explicitMemoryPurpose;
} MeshLoader_AllocationNotification;
</pre>

            <ul>
                <li> <code>structureType</code> is the type of the structure. </li>
                <li> <code>pNext</code> is <code>NULL</code> or a pointer to a structure extending this structure. </li>
                <li> If a parameter of <code>internalAllocationNotificationFunction</code> or <code>internalReallocationNotificationFunction</code>
                    <code>pMemory</code> will contain the address of the allocated resource. If a parameter of <code>internalFreeNotificationFunction</code>,
                    <code>pMemory</code> will contain the address of the resource that will be freed.</li>
                <li> If a parameter of <code>internalReallocationNotificationFunction</code>,
                    <code>pOldMemory</code> will contain the old address of the resource. </li>
                <li> If a parameter of <code>internalAllocationNotificationFunction</code> or <code>internalReallocationNotificationFunction</code>,
                    <code>size</code> will contain the size, in bytes, of the memory allocated at <code>pMemory</code>. </li>
                <li> If a parameter of <code>internalAllocationNotificationFunction</code> or <code>internalReallocationNotificationFunction</code>,
                    <code>alignment</code> will contain the alignment, in bytes, of the memory allocated at <code>pMemory</code>. This value is a power of two. </li>
                <li> <code>allocationScope</code> is a <a href="#MeshLoader_SystemAllocationScope">MeshLoader_SystemAllocationScope</a> value
                    specifying the allocation scope of the lifetime of the allocation. </li>
                <li> <code>explicitMemoryPurpose</code> is a pointer to a null-terminated, UTF-8 formatted <a href="#string">MeshLoader_StringLiteral</a>
                    specifying the explicit purpose of the allocation. </li>
            </ul>

            <p> <code>pNotification</code> is, just like the function it is passed into (<code>MeshLoader_AllocationNotification</code>), purely information.
                Consequently, the application <strong>must</strong> not apply any allocation or modification operations to the addresses received through the
                <code>pMemory</code> or <code>pOldMemory</code> values. </p>

        </div>

        <div>

            <h1 id="userDefinedJobs">7. User Defined Jobs</h1>

            <p> For object types/formats that are not available in the standard implementation, it can be extended with user-defined jobs.
                These are created by specifying an extending structure to the <a href="#MeshLoader_CreateJobInfo">MeshLoader_CreateJobInfo</a>
                structures in the <a href="#MeshLoader_JobsCreateInfo">MeshLoader_JobsCreateInfo</a> passed to the
                <a href="#MeshLoader_createJobs">MeshLoader_createJobs</a> call. These jobs are referred to as <strong>Custom Jobs</strong>. </p>

            <p> To access the Custom Job types and functions, include the "customJob" header </p>

<pre lang="c">
#include &lt;meshLoader/customJob&gt;
</pre>

            <div>

                <h2 id="userDefinedJobs-customJobCreation"> 7.1. Custom Job Creation </h2>

                <p> To create a custom job, add the <code>MeshLoader_CustomJobInfo</code> to the
                    <a href="#MeshLoader_JobsCreateInfo">MeshLoader_JobsCreateInfo</a><code>::pNext</code> chain when
                    <a href="#jobs-jobCreation">creating Job Objects</a>. The structure is defined as follows:
                    <a id="MeshLoader_CustomJobInfo"></a> </p>

<pre lang="c">
typedef struct {
    MeshLoader_StructureType            structureType;
    void                        const * pNext;
    void                              * pUserData;
    MeshLoader_Job_MainFunction         jobFunction;
} MeshLoader_CustomJobInfo;
</pre>
                <ul>
                    <li> <code>structureType</code> is the type of the structure. </li>
                    <li> <code>pNext</code> is NULL or a pointer to the structure extending this structure. </li>
                    <li> <code>pUserData</code> is a value to be interpreted by the implementation of the custom job.
                        When a worker thread will call the <code>jobFunction</code> to process a part of the job, the user
                        can acquire this value with <code>MeshLoader_Job_getUserData</code>. </li>
                    <li> <code>jobFunction</code> is a <a href="#MeshLoader_Job_MainFunction">MeshLoader_Job_MainFunction</a>
                        pointer to an application-defined function that is called by the implementation every time a Worker Thread
                        is assigned to process a part of the defined Job.</li>
                </ul>

                <h3>Valid Usage (Implicit)</h3>
                <ul>
                    <li> <small>MLUID-MeshLoader_CustomJobInfo-structureType</small> <br/>
                        <code>structureType</code> <strong>must</strong> be <code>MeshLoader_StructureType_CustomJobInfo</code>. </li>
                    <li> <small>MLUID-MeshLoader_CustomJobInfo-pNext</small> <br/>
                        <code>pNext</code> <strong>must</strong> either be <code>NULL</code>, or a <i>valid</i> pointer to a
                        <i>valid</i> structure that would be expected in the <code>pNext</code> chain of <a href="#MeshLoader_CreateJobInfo">MeshLoader_CreateJobInfo</a>. </li>
                    <li> <small>MLUID-MeshLoader_CustomJobInfo-jobFunction</small> <br/>
                        <code>jobFunction</code> <strong>must</strong> be a <i>valid</i> <a href="#MeshLoader_Job_MainFunction"></a> pointer to an application defined
                        Job main function. </li>
                </ul>

                <p> The <code>MeshLoader_Job_MainFunction</code> is described as follows:
                    <a id="MeshLoader_Job_MainFunction"></a> </p>

<pre lang="c">
typedef MeshLoader_Result ( * MeshLoader_Job_MainFunction ) (
        MeshLoader_Job_Context  context
);
</pre>

                <ul>
                    <li> <code> context </code> is a <a href="#MeshLoader_Job_Context">MeshLoader_Job_Context</a> object handle, representing the
                        data that is accessible from the function through API calls. </li>
                </ul>

                <h3>Valid Usage</h3>
                <ul>
                    <li> <small>MLUID-MeshLoader_Job_MainFunction-return-00029</small> <br/>
                        An application-defined function <code>MeshLoader_Job_MainFunction</code> <strong>must</strong>
                        return <code>MeshLoader_Result_Success</code> when the function executed successfully. </li>
                </ul>

                <p> The <code>MeshLoader_Job_Context</code> is defined as follows:
                    <a id="MeshLoader_Job_Context"></a> </p>

<pre lang="c">
MESH_LOADER_DEFINE_HANDLE ( MeshLoader_Job_Context )
</pre>

            </div>

            <div>

                <h2 id="userDefinedJobs-garbageCollection"> 7.2. Custom Job Garbage Collection </h2>

                <p> Since all jobs are executed on multiple CPU threads, a call to a <a href="#MeshLoader_Job_MainFunction">MeshLoader_Job_MainFunction</a>
                    is a call done from a separate thread to the main application thread, well-defined behaviour for Custom Jobs is hard to achieve. Added to this
                    is the large size of object files and the long times required to load these files. To bypass one of the major problems of this, that is
                    memory allocation, any large amount of data <strong>should</strong> be managed with the <code>MeshLoader_Job_*memory</code> functions.
                    These ensure that in the case of errors or thread termination, the memory is safely freed. </p>

                <p> To allocate memory from a <a href="#MeshLoader_Job_MainFunction">MeshLoader_Job_MainFunction</a>, call:
                    <a id="MeshLoader_Job_allocateMemory"></a> </p>

<pre lang="c">
MeshLoader_Result MeshLoader_Job_allocateMemory (
        MeshLoader_Job_Context      jobContext,
        MeshLoader_size             size,
        void                     ** ppMemory
);
</pre>
                <ul>
                    <li> <code>jobContext</code> is a <a href="#MeshLoader_Job_Context">MeshLoader_Job_Context</a> handle given as
                        a parameter in the <a href="#MeshLoader_Job_MainFunction">MeshLoader_Job_MainFunction</a>. </li>
                    <li> <code>size</code> is the size in bytes of the memory to allocate. </li>
                    <li> <code>ppMemory</code> is a pointer to the pointer to store the allocated memory into </li>
                </ul>

                <p> If the memory allocation fails, ppMemory will contain the <code>NULL</code> value. </p>

                <h3>Valid Usage (Implicit)</h3>
                <ul>
                    <li> <small>MLUID-MeshLoader_Job_allocateMemory-jobContext-parameter</small> <br/>
                        <code>jobContext</code> <strong>must</strong> be a <i>valid</i> <a href="#MeshLoader_Job_Context">MeshLoader_Job_Context</a> handle
                        received from the current <a href="#MeshLoader_Job_MainFunction">MeshLoader_Job_MainFunction</a> call. </li>
                    <li> <small>MLUID-MeshLoader_Job_allocateMemory-size-parameter</small> <br/>
                        <code>size</code> <strong>must</strong> be greater than <code>0</code>. </li>
                    <li> <small>MLUID-MeshLoader_Job_allocateMemory-ppMemory-parameter</small> <br/>
                        <code>ppMemory</code> <strong>must</strong> be a <i>valid</i> pointer to a <code>void *</code> value. </li>
                </ul>

                <h3>Return Codes</h3>
                <a href="#successCodes">Success</a>
                <ul>
                    <li> <code>MeshLoader_Result_Success</code> </li>
                </ul>
                <a href="#errorCodes">Failure</a>
                <ul>
                    <li> <code>MeshLoader_Result_OutOfMemory</code> </li>
                    <li> <code>MeshLoader_Result_MutexError</code> </li>
                </ul>

                <p> To allocate memory from a <a href="#MeshLoader_Job_MainFunction">MeshLoader_Job_MainFunction</a>, call:
                    <a id="MeshLoader_Job_allocateMemory2"></a> </p>

<pre lang="c">
MeshLoader_Result MeshLoader_Job_allocateMemory2 (
        MeshLoader_Job_Context      jobContext,
        MeshLoader_size             size,
        MeshLoader_size             alignment,
        void                     ** ppMemory
);
</pre>
                <ul>
                    <li> <code>jobContext</code> is a <a href="#MeshLoader_Job_Context">MeshLoader_Job_Context</a> handle given as
                        a parameter in the <a href="#MeshLoader_Job_MainFunction">MeshLoader_Job_MainFunction</a>. </li>
                    <li> <code>size</code> is the size, in bytes, of the memory to allocate. </li>
                    <li> <code>alignment</code> is the alignment, in bytes, of the memory to allocate. </li>
                    <li> <code>ppMemory</code> is a pointer to the pointer to store the allocated memory into </li>
                </ul>

                <p> If the memory allocation fails, ppMemory will contain the <code>NULL</code> value. </p>

                <h3>Valid Usage (Implicit)</h3>
                <ul>
                    <li> <small>MLUID-MeshLoader_Job_allocateMemory2-jobContext-parameter</small> <br/>
                        <code>jobContext</code> <strong>must</strong> be a <i>valid</i> <a href="#MeshLoader_Job_Context">MeshLoader_Job_Context</a> handle
                        received from the current <a href="#MeshLoader_Job_MainFunction">MeshLoader_Job_MainFunction</a> call. </li>
                    <li> <small>MLUID-MeshLoader_Job_allocateMemory2-size-parameter</small> <br/>
                        <code>size</code> <strong>must</strong> be greater than <code>0</code>. </li>
                    <li> <small>MLUID-MeshLoader_Job_allocateMemory2-alignment-parameter</small> <br/>
                        <code>alignment</code> <strong>must</strong> be a greater than <code>0</code> and <strong>must</strong> be a power of two. </li>
                    <li> <small>MLUID-MeshLoader_Job_allocateMemory2-ppMemory-parameter</small> <br/>
                        <code>ppMemory</code> <strong>must</strong> be a <i>valid</i> pointer to a <code>void *</code> value. </li>
                </ul>

                <h3>Return Codes</h3>
                <a href="#successCodes">Success</a>
                <ul>
                    <li> <code>MeshLoader_Result_Success</code> </li>
                </ul>
                <a href="#errorCodes">Failure</a>
                <ul>
                    <li> <code>MeshLoader_Result_OutOfMemory</code> </li>
                    <li> <code>MeshLoader_Result_MutexError</code> </li>
                </ul>

                <p> To reallocate memory from a <a href="#MeshLoader_Job_MainFunction">MeshLoader_Job_MainFunction</a>, call:
                    <a id="MeshLoader_Job_reallocateMemory"></a> </p>

<pre lang="c">
MeshLoader_Result MeshLoader_Job_reallocateMemory (
        MeshLoader_Job_Context      jobContext,
        void                      * pOldMemory,
        MeshLoader_size             size,
        void                     ** ppMemory
);
</pre>
                <ul>
                    <li> <code>jobContext</code> is a <a href="#MeshLoader_Job_Context">MeshLoader_Job_Context</a> handle given as
                        a parameter in the <a href="#MeshLoader_Job_MainFunction">MeshLoader_Job_MainFunction</a>. </li>
                    <li> <code>pOldMemory</code> is a pointer to the old memory that is to be reallocated. </li>
                    <li> <code>size</code> is the size in bytes of the memory to allocate. </li>
                    <li> <code>ppMemory</code> is a pointer to the pointer to store the allocated memory into </li>
                </ul>

                <p> If the memory allocation fails, ppMemory will contain the <code>NULL</code> value. </p>

                <h3>Valid Usage (Implicit)</h3>
                <ul>
                    <li> <small>MLUID-MeshLoader_Job_reallocateMemory-jobContext-parameter</small> <br/>
                        <code>jobContext</code> <strong>must</strong> be a <i>valid</i> <a href="#MeshLoader_Job_Context">MeshLoader_Job_Context</a> handle
                        received from the current <a href="#MeshLoader_Job_MainFunction">MeshLoader_Job_MainFunction</a> call. </li>
                    <li> <small>MLUID-MeshLoader_Job_reallocateMemory-pOldMemory-parameter</small> <br/>
                        <code>pOldMemory</code> <strong>must</strong> either be <code>NULL</code>, or a pointer to memory obtained from a previous
                        <a href="#MeshLoader_Job_allocateMemory">MeshLoader_Job_allocateMemory</a>,
                        <a href="#MeshLoader_Job_allocateMemory2">MeshLoader_Job_allocateMemory2</a>,
                        <a href="#MeshLoader_Job_reallocateMemory">MeshLoader_Job_reallocateMemory</a> or
                        <a href="#MeshLoader_Job_reallocateMemory2">MeshLoader_Job_reallocateMemory2</a> call. </li>
                    <li> <small>MLUID-MeshLoader_Job_reallocateMemory-ppMemory-parameter</small> <br/>
                        <code>ppMemory</code> <strong>must</strong> be a <i>valid</i> pointer to a <code>void *</code> value. </li>
                </ul>

                <h3>Return Codes</h3>
                <a href="#successCodes">Success</a>
                <ul>
                    <li> <code>MeshLoader_Result_Success</code> </li>
                </ul>
                <a href="#errorCodes">Failure</a>
                <ul>
                    <li> <code>MeshLoader_Result_OutOfMemory</code> </li>
                    <li> <code>MeshLoader_Result_MutexError</code> </li>
                </ul>

                <p> To reallocate memory from a <a href="#MeshLoader_Job_MainFunction">MeshLoader_Job_MainFunction</a>, call:
                    <a id="MeshLoader_Job_reallocateMemory2"></a> </p>

<pre lang="c">
MeshLoader_Result MeshLoader_Job_reallocateMemory2 (
        MeshLoader_Job_Context      jobContext,
        void                      * pOldMemory,
        MeshLoader_size             size,
        MeshLoader_size             alignment,
        void                     ** ppMemory
);
</pre>
                <ul>
                    <li> <code>jobContext</code> is a <a href="#MeshLoader_Job_Context">MeshLoader_Job_Context</a> handle given as
                        a parameter in the <a href="#MeshLoader_Job_MainFunction">MeshLoader_Job_MainFunction</a>. </li>
                    <li> <code>pOldMemory</code> is a pointer to the old memory that is to be reallocated. </li>
                    <li> <code>size</code> is the size, in bytes, of the memory to allocate. </li>
                    <li> <code>alignment</code> is the alignment, in bytes, of the memory to allocate. </li>
                    <li> <code>ppMemory</code> is a pointer to the pointer to store the allocated memory into </li>
                </ul>

                <p> If the memory allocation fails, ppMemory will contain the <code>NULL</code> value. </p>

                <h3>Valid Usage (Implicit)</h3>
                <ul>
                    <li> <small>MLUID-MeshLoader_Job_reallocateMemory2-jobContext-parameter</small> <br/>
                        <code>jobContext</code> <strong>must</strong> be a <i>valid</i> <a href="#MeshLoader_Job_Context">MeshLoader_Job_Context</a> handle
                        received from the current <a href="#MeshLoader_Job_MainFunction">MeshLoader_Job_MainFunction</a> call. </li>
                    <li> <small>MLUID-MeshLoader_Job_reallocateMemory2-pOldMemory-parameter</small> <br/>
                        <code>pOldMemory</code> <strong>must</strong> either be <code>NULL</code>, or a pointer to memory obtained from a previous
                        <a href="#MeshLoader_Job_allocateMemory">MeshLoader_Job_allocateMemory</a>,
                        <a href="#MeshLoader_Job_allocateMemory2">MeshLoader_Job_allocateMemory2</a>,
                        <a href="#MeshLoader_Job_reallocateMemory">MeshLoader_Job_reallocateMemory</a> or
                        <a href="#MeshLoader_Job_reallocateMemory2">MeshLoader_Job_reallocateMemory2</a> call. </li>
                    <li> <small>MLUID-MeshLoader_Job_reallocateMemory2-alignment-parameter</small> <br/>
                        <code>alignment</code> <strong>must</strong> be a greater than <code>0</code> and <strong>must</strong> be a power of two. </li>
                    <li> <small>MLUID-MeshLoader_Job_reallocateMemory2-ppMemory-parameter</small> <br/>
                        <code>ppMemory</code> <strong>must</strong> be a <i>valid</i> pointer to a <code>void *</code> value. </li>
                </ul>

                <h3>Return Codes</h3>
                <a href="#successCodes">Success</a>
                <ul>
                    <li> <code>MeshLoader_Result_Success</code> </li>
                </ul>
                <a href="#errorCodes">Failure</a>
                <ul>
                    <li> <code>MeshLoader_Result_OutOfMemory</code> </li>
                    <li> <code>MeshLoader_Result_MutexError</code> </li>
                </ul>

                <p> To free memory from a <a href="#MeshLoader_Job_MainFunction">MeshLoader_Job_MainFunction</a>, call:
                    <a id="MeshLoader_Job_freeMemory"></a> </p>

<pre lang="c">
MeshLoader_Result MeshLoader_Job_freeMemory (
        MeshLoader_Job_Context    jobContext,
        void                    * pMemory
);
</pre>
                <ul>
                    <li> <code>jobContext</code> is a <a href="#MeshLoader_Job_Context">MeshLoader_Job_Context</a> handle given as
                        a parameter in the <a href="#MeshLoader_Job_MainFunction">MeshLoader_Job_MainFunction</a>. </li>
                    <li> <code>pMemory</code> is a pointer to the allocated memory to free. </li>
                </ul>

                <h3>Valid Usage (Implicit)</h3>
                <ul>
                    <li> <small>MLUID-MeshLoader_Job_freeMemory-jobContext-parameter</small> <br/>
                        <code>jobContext</code> <strong>must</strong> be a <i>valid</i> <a href="#MeshLoader_Job_Context">MeshLoader_Job_Context</a> handle
                        received from the current <a href="#MeshLoader_Job_MainFunction">MeshLoader_Job_MainFunction</a> call. </li>
                    <li> <small>MLUID-MeshLoader_Job_freeMemory-pMemory-parameter</small> <br/>
                        <code>pMemory</code> <strong>must</strong> either be <code>NULL</code> or a <i>valid</i> pointer obtained from a previous
                        <a href="#MeshLoader_Job_allocateMemory">MeshLoader_Job_allocateMemory</a>,
                        <a href="#MeshLoader_Job_allocateMemory2">MeshLoader_Job_allocateMemory2</a>,
                        <a href="#MeshLoader_Job_reallocateMemory">MeshLoader_Job_reallocateMemory</a> or
                        <a href="#MeshLoader_Job_reallocateMemory2">MeshLoader_Job_reallocateMemory2</a> call. </li>
                </ul>

                <h3>Return Codes</h3>
                <a href="#successCodes">Success</a>
                <ul>
                    <li> <code>MeshLoader_Result_Success</code> </li>
                </ul>
                <a href="#errorCodes">Failure</a>
                <ul>
                    <li> <code>MeshLoader_Result_OutOfMemory</code> </li>
                    <li> <code>MeshLoader_Result_MutexError</code> </li>
                </ul>

                <p> To release the memory tracking of a pointer allocated in a <a href="#MeshLoader_Job_MainFunction">MeshLoader_Job_MainFunction</a>, call:
                    <a id="MeshLoader_Job_releaseMemory"></a> </p>

<pre lang="c">
MeshLoader_Result MeshLoader_Job_releaseMemory (
        MeshLoader_Job_Context    jobContext,
        void                    * pMemory
);
</pre>
                <ul>
                    <li> <code>jobContext</code> is a <a href="#MeshLoader_Job_Context">MeshLoader_Job_Context</a> handle given as
                        a parameter in the <a href="#MeshLoader_Job_MainFunction">MeshLoader_Job_MainFunction</a>. </li>
                    <li> <code>pMemory</code> is a pointer to the allocated memory to release from garbage collection tracking. </li>
                </ul>

                <p> This function is used to release memory from garbage collection tracking, making it possible to pass memory to objects
                    that are to be used after the Job has finished, such as Mesh Data. </p>

                <h3>Valid Usage (Implicit)</h3>
                <ul>
                    <li> <small>MLUID-MeshLoader_Job_releaseMemory-jobContext-parameter</small> <br/>
                        <code>jobContext</code> <strong>must</strong> be a <i>valid</i> <a href="#MeshLoader_Job_Context">MeshLoader_Job_Context</a> handle
                        received from the current <a href="#MeshLoader_Job_MainFunction">MeshLoader_Job_MainFunction</a> call. </li>
                    <li> <small>MLUID-MeshLoader_Job_releaseMemory-pMemory-parameter</small> <br/>
                        <code>pMemory</code> <strong>must</strong> be a <i>valid</i> pointer obtained from a previous
                        <a href="#MeshLoader_Job_allocateMemory">MeshLoader_Job_allocateMemory</a>,
                        <a href="#MeshLoader_Job_allocateMemory2">MeshLoader_Job_allocateMemory2</a>,
                        <a href="#MeshLoader_Job_reallocateMemory">MeshLoader_Job_reallocateMemory</a> or
                        <a href="#MeshLoader_Job_reallocateMemory2">MeshLoader_Job_reallocateMemory2</a> call. </li>
                </ul>

                <h3>Return Codes</h3>
                <a href="#successCodes">Success</a>
                <ul>
                    <li> <code>MeshLoader_Result_Success</code> </li>
                </ul>
                <a href="#errorCodes">Failure</a>
                <ul>
                    <li> <code>MeshLoader_Result_OutOfMemory</code> </li>
                    <li> <code>MeshLoader_Result_MutexError</code> </li>
                </ul>

            </div>

            <div>

                <h2 id="userDefinedJobs-customJobAPIFunctions">7.3. Custom Job API Functions</h2>

                <p> To acquire the <code>pUserData</code> given to the <a href="#MeshLoader_CustomJobInfo">MeshLoader_CustomJobInfo</a>
                    at job creation, call:
                    <a id="MeshLoader_Job_getUserData"></a> </p>

<pre lang="c">
MeshLoader_Result MeshLoader_Job_getUserData (
        MeshLoader_Job_Context    jobContext,
        void                   ** ppUserData
);
</pre>

                <ul>
                    <li> <code>jobContext</code> is a <a href="#MeshLoader_Job_Context">MeshLoader_Job_Context</a> handle given as
                        a parameter in the <a href="#MeshLoader_Job_MainFunction">MeshLoader_Job_MainFunction</a>. </li>
                    <li> <code>ppUserData</code> is a pointer to a pointer to store the <a href="#MeshLoader_CustomJobInfo">MeshLoader_CustomJobInfo</a><code>::pUserData</code>
                        value into upon a successful call.</li>
                </ul>

                <h3>Valid Usage (Implicit)</h3>
                <ul>
                    <li> <small>MLUID-MeshLoader_Job_getUserData-jobContext-parameter</small> <br/>
                        <code>jobContext</code> <strong>must</strong> be a <i>valid</i> <a href="#MeshLoader_Job_Context">MeshLoader_Job_Context</a> handle
                        received from the current <a href="#MeshLoader_Job_MainFunction">MeshLoader_Job_MainFunction</a> call. </li>
                    <li> <small>MLUID-MeshLoader_Job_getUserData-ppUserData-parameter</small> <br/>
                        <code>ppUserData</code> <strong>must</strong> be a <i>valid</i> pointer to a <code>void *</code> value. </li>
                </ul>

                <h3>Return Codes</h3>
                <a href="#successCodes">Success</a>
                <ul>
                    <li> <code>MeshLoader_Result_Success</code> </li>
                </ul>

                <p> To store data for the next call of <a href="#MeshLoader_Job_MainFunction">MeshLoader_Job_MainFunction</a>, call:
                    <a id="MeshLoader_Job_setDataForNextCall"></a> </p>

<pre lang="c">
MeshLoader_Result MeshLoader_Job_setDataForNextCall (
        MeshLoader_Job_Context    jobContext,
        void                    * pData
);
</pre>

                <ul>
                    <li> <code>jobContext</code> is a <a href="#MeshLoader_Job_Context">MeshLoader_Job_Context</a> handle given as
                        a parameter in the <a href="#MeshLoader_Job_MainFunction">MeshLoader_Job_MainFunction</a>. </li>
                    <li> <code>pData</code> is a pointer to the data to store for the next call. </li>
                </ul>

                <h3>Valid Usage (Implicit)</h3>
                <ul>
                    <li> <small>MLUID-MeshLoader_Job_setDataForNextCall-jobContext-parameter</small> <br/>
                        <code>jobContext</code> <strong>must</strong> be a <i>valid</i> <a href="#MeshLoader_Job_Context">MeshLoader_Job_Context</a> handle
                        received from the current <a href="#MeshLoader_Job_MainFunction">MeshLoader_Job_MainFunction</a> call. </li>
                </ul>

                <h3>Return Codes</h3>
                <a href="#successCodes">Success</a>
                <ul>
                    <li> <code>MeshLoader_Result_Success</code> </li>
                </ul>

                <p> To acquire the data stored by the previous call of <a href="#MeshLoader_Job_MainFunction">MeshLoader_Job_MainFunction</a>, call:
                    <a id="MeshLoader_Job_getDataFromPreviousCall"></a> </p>

<pre lang="c">
MeshLoader_Result MeshLoader_Job_getDataFromPreviousCall (
        MeshLoader_Job_Context    jobContext,
        void                   ** ppData
);
</pre>

                <ul>
                    <li> <code>jobContext</code> is a <a href="#MeshLoader_Job_Context">MeshLoader_Job_Context</a> handle given as
                        a parameter in the <a href="#MeshLoader_Job_MainFunction">MeshLoader_Job_MainFunction</a>. </li>
                    <li> <code>ppData</code> is a pointer to a pointer to acquire the data from the previous call into, after a successful call.</li>
                </ul>

                <h3>Valid Usage (Implicit)</h3>
                <ul>
                    <li> <small>MLUID-MeshLoader_Job_getDataFromPreviousCall-jobContext-parameter</small> <br/>
                        <code>jobContext</code> <strong>must</strong> be a <i>valid</i> <a href="#MeshLoader_Job_Context">MeshLoader_Job_Context</a> handle
                        received from the current <a href="#MeshLoader_Job_MainFunction">MeshLoader_Job_MainFunction</a> call. </li>
                    <li> <small>MLUID-MeshLoader_Job_getDataFromPreviousCall-ppData-parameter</small> <br/>
                        <code>ppData</code> <strong>must</strong> be a <i>valid</i> pointer to a <code>void *</code> value. </li>
                </ul>

                <h3>Return Codes</h3>
                <a href="#successCodes">Success</a>
                <ul>
                    <li> <code>MeshLoader_Result_Success</code> </li>
                </ul>

                <p> To get the progress of the job, call:
                    <a id="MeshLoader_Job_getProgress"></a> </p>

<pre lang="c">
MeshLoader_Result MeshLoader_Job_getProgress (
        MeshLoader_Job_Context  jobContext,
        float                 * pProgress
);
</pre>

                <ul>
                    <li> <code>jobContext</code> is a <a href="#MeshLoader_Job_Context">MeshLoader_Job_Context</a> handle given as
                        a parameter in the <a href="#MeshLoader_Job_MainFunction">MeshLoader_Job_MainFunction</a>. </li>
                    <li> <code>pProgress</code> is a pointer to a float to load the progress into after a successful call. The progress is a value between
                        <code>0.0f</code> and <code>1.0f</code>, <code>0.0f</code> representing a job that is 0% done, and <code>1.0f</code>
                        representing a job that is 100% done. As an example, a progress of <code>0.25f</code> represents a job progress of 25%. </li>
                </ul>

                <h3>Valid Usage (Implicit)</h3>
                <ul>
                    <li> <small>MLUID-MeshLoader_Job_getProgress-jobContext-parameter</small> <br/>
                        <code>jobContext</code> <strong>must</strong> be a <i>valid</i> <a href="#MeshLoader_Job_Context">MeshLoader_Job_Context</a> handle
                        received from the current <a href="#MeshLoader_Job_MainFunction">MeshLoader_Job_MainFunction</a> call. </li>
                    <li> <small>MLUID-MeshLoader_Job_getProgress-pProgress-parameter</small> <br/>
                        <code>pProgress</code> <strong>must</strong> be a <i>valid</i> pointer to a <a href="#float">float</a> value. </li>
                </ul>

                <h3>Return Codes</h3>
                <a href="#successCodes">Success</a>
                <ul>
                    <li> <code>MeshLoader_Result_Success</code> </li>
                </ul>

                <p> To set the progress of the job, call:
                    <a id="MeshLoader_Job_setProgress"></a> </p>

<pre lang="c">
MeshLoader_Result MeshLoader_Job_setProgress (
        MeshLoader_Job_Context  jobContext,
        float                   progress
);
</pre>

                <ul>
                    <li> <code>jobContext</code> is a <a href="#MeshLoader_Job_Context">MeshLoader_Job_Context</a> handle given as
                        a parameter in the <a href="#MeshLoader_Job_MainFunction">MeshLoader_Job_MainFunction</a>. </li>
                    <li> <code>progress</code> is a <a href="#float">float</a> to store the progress from. The progress is a value between
                        <code>0.0f</code> and <code>1.0f</code>, <code>0.0f</code> representing a job that is 0% done, and <code>1.0f</code>
                        representing a job that is 100% done. As an example, a progress of <code>0.25f</code> represents a job progress of 25%. </li>
                </ul>

                <h3>Valid Usage (Implicit)</h3>
                <ul>
                    <li> <small>MLUID-MeshLoader_Job_setProgress-jobContext-parameter</small> <br/>
                        <code>jobContext</code> <strong>must</strong> be a <i>valid</i> <a href="#MeshLoader_Job_Context">MeshLoader_Job_Context</a> handle
                        received from the current <a href="#MeshLoader_Job_MainFunction">MeshLoader_Job_MainFunction</a> call. </li>
                    <li> <small>MLUID-MeshLoader_Job_setProgress-progress-parameter</small> <br/>
                        <code>parameter</code> <strong>must</strong> be greater than or equal to <code>0.0f</code> and
                        less than or equal to <code>1.0f</code>. </li>
                </ul>

                <h3>Return Codes</h3>
                <a href="#successCodes">Success</a>
                <ul>
                    <li> <code>MeshLoader_Result_Success</code> </li>
                </ul>

                <p> To get the load mode of the job, call:
                    <a id="MeshLoader_Job_getLoadMode"></a> </p>

<pre lang="c">
MeshLoader_Result MeshLoader_Job_getLoadMode (
        MeshLoader_Job_Context          jobContext,
        MeshLoader_MeshLoadModeFlags  * pLoadMode
);
</pre>

                <ul>
                    <li> <code>jobContext</code> is a <a href="#MeshLoader_Job_Context">MeshLoader_Job_Context</a> handle given as
                        a parameter in the <a href="#MeshLoader_Job_MainFunction">MeshLoader_Job_MainFunction</a>. </li>
                    <li> <code>pLoadMode</code> is a pointer to a <a href="#MeshLoader_MeshLoadModeFlags">MeshLoader_MeshLoadModeFlags</a> to load the load mode into.
                        This will contain a bitmask of <a href="#MeshLoader_MeshLoadModeFlagBits">MeshLoader_MeshLoadModeFlagBits</a>, each specifying
                        a specific format of data to load after a successful call.</li>
                </ul>

                <h3>Valid Usage (Implicit)</h3>
                <ul>
                    <li> <small>MLUID-MeshLoader_Job_getLoadMode-jobContext-parameter</small> <br/>
                        <code>jobContext</code> <strong>must</strong> be a <i>valid</i> <a href="#MeshLoader_Job_Context">MeshLoader_Job_Context</a> handle
                        received from the current <a href="#MeshLoader_Job_MainFunction">MeshLoader_Job_MainFunction</a> call. </li>
                    <li> <small>MLUID-MeshLoader_Job_getLoadMode-pLoadMode-parameter</small> <br/>
                        <code>pLoadMode</code> <strong>must</strong> be a <i>valid</i> pointer to a <a href="#MeshLoader_MeshLoadModeFlags">MeshLoader_MeshLoadModeFlags</a> value. </li>
                </ul>

                <h3>Return Codes</h3>
                <a href="#successCodes">Success</a>
                <ul>
                    <li> <code>MeshLoader_Result_Success</code> </li>
                </ul>

                <p> To get the input path of the job, call:
                    <a id="MeshLoader_Job_getInputPath"></a> </p>

<pre lang="c">
MeshLoader_Result MeshLoader_Job_getInputPath (
        MeshLoader_Job_Context        jobContext,
        MeshLoader_StringLiteral    * pInputPath
);
</pre>

                <ul>
                    <li> <code>jobContext</code> is a <a href="#MeshLoader_Job_Context">MeshLoader_Job_Context</a> handle given as
                        a parameter in the <a href="#MeshLoader_Job_MainFunction">MeshLoader_Job_MainFunction</a>. </li>
                    <li> <code>pInputPath</code> is a pointer to a <a href="#string">MeshLoader_StringLiteral</a> to load the input path of the mesh file into.
                        This will contain a null-terminated, UTF-8 formatted String after a successful call.</li>
                </ul>

                <h3>Valid Usage (Implicit)</h3>
                <ul>
                    <li> <small>MLUID-MeshLoader_Job_getInputPath-jobContext-parameter</small> <br/>
                        <code>jobContext</code> <strong>must</strong> be a <i>valid</i> <a href="#MeshLoader_Job_Context">MeshLoader_Job_Context</a> handle
                        received from the current <a href="#MeshLoader_Job_MainFunction">MeshLoader_Job_MainFunction</a> call. </li>
                    <li> <small>MLUID-MeshLoader_Job_getInputPath-pInputPath-parameter</small> <br/>
                        <code>pInputPath</code> <strong>must</strong> be a <i>valid</i> pointer to a <a href="#string">MeshLoader_StringLiteral</a> value. </li>
                </ul>

                <h3>Return Codes</h3>
                <a href="#successCodes">Success</a>
                <ul>
                    <li> <code>MeshLoader_Result_Success</code> </li>
                </ul>

                <p> To set the Mesh Vertex Data, call:
                    <a id="MeshLoader_Job_setMeshVertexData"></a> </p>

<pre lang="c">
MeshLoader_Result MeshLoader_Job_setMeshVertexData (
        MeshLoader_Job_Context          jobContext,
        MeshLoader_uint32               vertexCount,
        MeshLoader_VertexData   const * pVertices
);
</pre>

                <ul>
                    <li> <code>jobContext</code> is a <a href="#MeshLoader_Job_Context">MeshLoader_Job_Context</a> handle given as
                        a parameter in the <a href="#MeshLoader_Job_MainFunction">MeshLoader_Job_MainFunction</a>. </li>
                    <li> <code>vertexCount</code> is an integer specifying the number of vertices loaded by the Job. </li>
                    <li> <code>pInputPath</code> is a pointer to an array of <a href="#MeshLoader_VertexData">MeshLoader_VertexData</a> structures containing
                        the vertices of the mesh.</li>
                </ul>

                <h3>Valid Usage</h3>
                <ul>
                    <li> <small>MLUID-MeshLoader_Job_setMeshVertexData-pointerLifetime-00030</small> <br/>
                        The memory at the <code>pVertices</code> pointer <strong>must</strong> not be freed from the Job if the call was successful, if it was
                        allocated dynamically in the Job.</li>
                    <li> <small>MLUID-MeshLoader_Job_setMeshVertexData-garbageCollector-00031</small> <br/>
                        If the memory at the <code>pVertices</code> pointer was allocated using <a href="#MeshLoader_Job_allocateMemory">MeshLoader_Job_allocateMemory</a>,
                        <a href="#MeshLoader_Job_allocateMemory2">MeshLoader_Job_allocateMemory2</a>, <a href="#MeshLoader_Job_reallocateMemory">MeshLoader_Job_reallocateMemory</a> or
                        <a href="#MeshLoader_Job_reallocateMemory2">MeshLoader_Job_reallocateMemory2</a>, it <strong>must</strong> not be freed and it <strong>must</strong>
                        be released right before (ideal case) or right after to this call using <a href="#MeshLoader_Job_releaseMemory">MeshLoader_Job_releaseMemory</a>. </li>
                </ul>

                <h3>Valid Usage (Implicit)</h3>
                <ul>
                    <li> <small>MLUID-MeshLoader_Job_setMeshVertexData-jobContext-parameter</small> <br/>
                        <code>jobContext</code> <strong>must</strong> be a <i>valid</i> <a href="#MeshLoader_Job_Context">MeshLoader_Job_Context</a> handle
                        received from the current <a href="#MeshLoader_Job_MainFunction">MeshLoader_Job_MainFunction</a> call. </li>
                    <li> <small>MLUID-MeshLoader_Job_setMeshVertexData-vertexCount-parameter</small> <br/>
                        <code>vertexCount</code> <strong>must</strong> be greater than <code>0</code>. </li>
                    <li> <small>MLUID-MeshLoader_Job_setMeshVertexData-pVertices-parameter</small> <br/>
                        <code>pVertices</code> <strong>must</strong> be a <i>valid</i> pointer to an array of <code>vertexCount</code>
                        valid <a href="#MeshLoader_VertexData">MeshLoader_VertexData</a> structures. </li>
                </ul>

                <h3>Return Codes</h3>
                <a href="#successCodes">Success</a>
                <ul>
                    <li> <code>MeshLoader_Result_Success</code> </li>
                </ul>

                <p> To set the Mesh Face Data, call:
                    <a id="MeshLoader_Job_setMeshFaceData"></a> </p>

<pre lang="c">
MeshLoader_Result MeshLoader_Job_setMeshFaceData (
        MeshLoader_Job_Context          jobContext,
        MeshLoader_uint32               faceCount,
        MeshLoader_FaceData     const * pFaces
);
</pre>

                <ul>
                    <li> <code>jobContext</code> is a <a href="#MeshLoader_Job_Context">MeshLoader_Job_Context</a> handle given as
                        a parameter in the <a href="#MeshLoader_Job_MainFunction">MeshLoader_Job_MainFunction</a>. </li>
                    <li> <code>faceCount</code> is an integer specifying the number of faces loaded by the Job. </li>
                    <li> <code>pFaces</code> is a pointer to an array of <a href="#MeshLoader_FaceData">MeshLoader_FaceData</a> structures containing
                        the faces of the mesh.</li>
                </ul>

                <h3>Valid Usage</h3>
                <ul>
                    <li> <small>MLUID-MeshLoader_Job_setMeshFaceData-pointerLifetime-00032</small> <br/>
                        The memory at the <code>pVertices</code> pointer <strong>must</strong> not be freed from the Job if the call was successful, if it was
                        allocated dynamically in the Job.</li>
                    <li> <small>MLUID-MeshLoader_Job_setMeshFaceData-garbageCollector-00033</small> <br/>
                        If the memory at the <code>pFaces</code> pointer was allocated using <a href="#MeshLoader_Job_allocateMemory">MeshLoader_Job_allocateMemory</a>,
                        <a href="#MeshLoader_Job_allocateMemory2">MeshLoader_Job_allocateMemory2</a>, <a href="#MeshLoader_Job_reallocateMemory">MeshLoader_Job_reallocateMemory</a> or
                        <a href="#MeshLoader_Job_reallocateMemory2">MeshLoader_Job_reallocateMemory2</a>, it <strong>must</strong> not be freed and it <strong>must</strong>
                        be released right before (ideal case) or right after to this call using <a href="#MeshLoader_Job_releaseMemory">MeshLoader_Job_releaseMemory</a>. </li>
                </ul>

                <h3>Valid Usage (Implicit)</h3>
                <ul>
                    <li> <small>MLUID-MeshLoader_Job_setMeshFaceData-jobContext-parameter</small> <br/>
                        <code>jobContext</code> <strong>must</strong> be a <i>valid</i> <a href="#MeshLoader_Job_Context">MeshLoader_Job_Context</a> handle
                        received from the current <a href="#MeshLoader_Job_MainFunction">MeshLoader_Job_MainFunction</a> call. </li>
                    <li> <small>MLUID-MeshLoader_Job_setMeshFaceData-faceCount-parameter</small> <br/>
                        <code>faceCount</code> <strong>must</strong> be greater than <code>0</code>. </li>
                    <li> <small>MLUID-MeshLoader_Job_setMeshFaceData-pFaces-parameter</small> <br/>
                        <code>pFaces</code> <strong>must</strong> be a <i>valid</i> pointer to an array of <code>faceCount</code>
                        valid <a href="#MeshLoader_FaceData">MeshLoader_FaceData</a> structures. </li>
                </ul>

                <h3>Return Codes</h3>
                <a href="#successCodes">Success</a>
                <ul>
                    <li> <code>MeshLoader_Result_Success</code> </li>
                </ul>

                <p> To set the Mesh Index Data, call:
                    <a id="MeshLoader_Job_setMeshIndexData"></a> </p>

<pre lang="c">
MeshLoader_Result MeshLoader_Job_setMeshIndexData (
        MeshLoader_Job_Context          jobContext,
        MeshLoader_IndexData    const * pIndexData
);
</pre>

                <ul>
                    <li> <code>jobContext</code> is a <a href="#MeshLoader_Job_Context">MeshLoader_Job_Context</a> handle given as
                        a parameter in the <a href="#MeshLoader_Job_MainFunction">MeshLoader_Job_MainFunction</a>. </li>
                    <li> <code>pIndexData</code> is a pointer to a <a href="#MeshLoader_IndexData">MeshLoader_IndexData</a> structure containing
                        the index data of the mesh.</li>
                </ul>

                <h3>Valid Usage</h3>
                <ul>
                    <li> <small>MLUID-MeshLoader_Job_setMeshIndexData-pointerLifetime-00034</small> <br/>
                        The memory at the <code>pVertices</code> pointer <strong>must</strong> not be freed from the Job if the call was successful, if it was
                        allocated dynamically in the Job.</li>
                    <li> <small>MLUID-MeshLoader_Job_setMeshIndexData-garbageCollector-00035</small> <br/>
                        If the memory at the <code>pIndexData</code> pointer or the memory at the <a href="#MeshLoader_IndexData">MeshLoader_IndexData</a><code>::pIndices</code>
                        pointer was allocated using <a href="#MeshLoader_Job_allocateMemory">MeshLoader_Job_allocateMemory</a>,
                        <a href="#MeshLoader_Job_allocateMemory2">MeshLoader_Job_allocateMemory2</a>, <a href="#MeshLoader_Job_reallocateMemory">MeshLoader_Job_reallocateMemory</a> or
                        <a href="#MeshLoader_Job_reallocateMemory2">MeshLoader_Job_reallocateMemory2</a>, it <strong>must</strong> not be freed and it <strong>must</strong>
                        be released right before (ideal case) or right after to this call using <a href="#MeshLoader_Job_releaseMemory">MeshLoader_Job_releaseMemory</a>. </li>
                </ul>

                <h3>Valid Usage (Implicit)</h3>
                <ul>
                    <li> <small>MLUID-MeshLoader_Job_setMeshIndexData-jobContext-parameter</small> <br/>
                        <code>jobContext</code> <strong>must</strong> be a <i>valid</i> <a href="#MeshLoader_Job_Context">MeshLoader_Job_Context</a> handle
                        received from the current <a href="#MeshLoader_Job_MainFunction">MeshLoader_Job_MainFunction</a> call. </li>
                    <li> <small>MLUID-MeshLoader_Job_setMeshIndexData-pFaces-pIndexData</small> <br/>
                        <code>pIndexData</code> <strong>must</strong> be a <i>valid</i> pointer to a <i>valid</i>
                        <a href="#MeshLoader_IndexData">MeshLoader_IndexData</a> structure, its <code>indexCount</code> <strong>must</strong>.
                        be greater than <code>0</code> and its <code>pIndices</code> <strong>must</strong> be a <i>valid</i> pointer to an array
                        of <code>indexCount</code> <i>valid</i> <a href="#int">MeshLoader_uint32</a> values.</li>
                </ul>

                <h3>Return Codes</h3>
                <a href="#successCodes">Success</a>
                <ul>
                    <li> <code>MeshLoader_Result_Success</code> </li>
                </ul>

                <p> To mark a job as finished, call:
                    <a id="MeshLoader_Job_finish"></a> </p>

<pre lang="c">
MeshLoader_Result MeshLoader_Job_finish (
        MeshLoader_Job_Context          jobContext
);
</pre>

                <ul>
                    <li> <code>jobContext</code> is a <a href="#MeshLoader_Job_Context">MeshLoader_Job_Context</a> handle given as
                        a parameter in the <a href="#MeshLoader_Job_MainFunction">MeshLoader_Job_MainFunction</a>. </li>
                </ul>

                <p> This function will cause the Mesh Loader Library implementation stop calling this function, and mark the executed Job as
                    <strong class="strong-state-description">Finished</strong>. Any resources that are scoped to the Job and are persistent <strong>must</strong>
                    be released, cleared or freed prior to this call. </p>

                <h3>Valid Usage</h3>
                <ul>
                    <li> <small>MLUID-MeshLoader_Job_finish-pointerLifetime-00036</small> <br/>
                        Any memory allocated before this call that is scoped to this Job <strong>must</strong> be freed before this call. </li>
                    <li> <small>MLUID-MeshLoader_Job_finish-garbageCollector-00037</small> <br/>
                        Any memory allocated before this call using <a href="#MeshLoader_Job_allocateMemory">MeshLoader_Job_allocateMemory</a>,
                        <a href="#MeshLoader_Job_allocateMemory2">MeshLoader_Job_allocateMemory2</a>, <a href="#MeshLoader_Job_reallocateMemory">MeshLoader_Job_reallocateMemory</a> or
                        <a href="#MeshLoader_Job_reallocateMemory2">MeshLoader_Job_reallocateMemory2</a>, that is not to be freed <strong>must</strong>
                        be released from the scope of the Worker using <a href="#MeshLoader_Job_releaseMemory">MeshLoader_Job_releaseMemory</a> before this call. </li>
                </ul>

                <h3>Valid Usage (Implicit)</h3>
                <ul>
                    <li> <small>MLUID-MeshLoader_Job_setMeshIndexData-jobContext-parameter</small> <br/>
                        <code>jobContext</code> <strong>must</strong> be a <i>valid</i> <a href="#MeshLoader_Job_Context">MeshLoader_Job_Context</a> handle
                        received from the current <a href="#MeshLoader_Job_MainFunction">MeshLoader_Job_MainFunction</a> call. </li>
                </ul>

                <h3>Return Codes</h3>
                <a href="#successCodes">Success</a>
                <ul>
                    <li> <code>MeshLoader_Result_Success</code> </li>
                </ul>

            </div>

            <div>

                <h2 id="userDefinedJobs-customJobGuidelines">7.4. Custom Job Implementation Guidelines</h2>

                <p> In order to facilitate easy pause, resume and stop of jobs and to avoid unresponsive threads,
                    job execution functions <strong>should</strong> be implemented to execute recurrently, either
                    with a state machine or by other means. The Job Function
                    has no method of receiving a stop/terminate request, and must wait for the stop of the call to treat those requests.
                    Consequently, the function should not exceed a given period of execution time, depending on scenario. </p>

                <p> If a recurrent function approach is not chosen, another approach would be defining a stop conditional variable and passing
                    it in the <a href="#MeshLoader_CustomJobInfo">MeshLoader_CustomJobInfo</a><code>::pUserData</code> member, and acquiring it
                    in the Job Main Function with <a href="#MeshLoader_Job_getUserData">MeshLoader_Job_getUserData</a>. </p>

                <p> The Job Main Function should also account for specific allocate/free resource function/states to
                    make it easy to treat error states and possible leaks in the case of stop/termination. </p>

                <p> The user defined job <strong>must</strong> treat all operations with care, as in the case of in-thread runtime-errors, traps, segmentation faults and
                    any other execution halting errors, memory freeing is not guaranteed. </p>

                <p> To avoid memory issues, use the <a href="#userDefinedJobs-garbageCollection">Garbage Collection Allocation Functions</a>. These are not mandatory,
                    such as not requiring any allocation, having the memory pre-allocated inside the
                    <a href="#MeshLoader_CustomJobInfo">MeshLoader_CustomJobInfo</a><code>::pUserData</code>, or if thread is not error-prone and no terminate calls are to be done. </p>

                <p> The standard implementation object loader functions are implemented using only the <a href="#userDefinedJobs-customJobAPIFunctions">Custom Job API Functions</a>
                    and the <a href="#userDefinedJobs-garbageCollection">Garbage Collection Memory Allocators</a> for robustness, so these can be used as examples: </p>

                <ul>
                    <li> Wavefront .OBJ file loader, recurrent calls: <a href="https://github.com/LoghinVladDev/meshLoader/blob/master/src/implementation/workers/objWorker.c">objWorker.c</a>. </li>
                </ul>

            </div>

        </div>

    </main>

</div>

<script src="scripts/sidebarGenerator.js"></script>
<script src="scripts/pageTheme.js"></script>
<script src="../scripts/syntaxHighlighter/languages/c.js"></script>
<script src="../scripts/syntaxHighlighter/syntax.js"></script>

</body>
</html>